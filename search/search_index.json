{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Freeact is a lightweight, general-purpose agent that acts via code actions rather than JSON tool calls<sup>1</sup>. It writes executable Python code that can call multiple tools programmatically, process intermediate results, and use loops and conditionals in a single pass, which would otherwise require many inference rounds with JSON tool calling.</p> <p>Beyond executing tools, freeact can develop new tools from successful code actions, evolving its own tool library over time. Tools are defined via Python interfaces, progressively discovered and loaded from the agent's workspace<sup>2</sup> rather than consuming context upfront. All execution happens locally in a secure sandbox via ipybox and sandbox-runtime.</p> <p>Supported models</p> <p>Freeact supports models compatible with Pydantic AI, with <code>gemini-3-flash-preview</code> as the current default.</p>"},{"location":"#interfaces","title":"Interfaces","text":"<p>Freeact provides a Python SDK for application integration, and a CLI tool for running the agent in a terminal.</p>"},{"location":"#features","title":"Features","text":"<p>Freeact combines the following elements into a coherent system:</p> Feature Description Programmatic tool calling Agents call tools programmatically within code actions rather than through JSON structures. Freeact generates typed Python APIs from MCP tool schemas to enable this. LLMs are heavily pretrained on Python code, making this more reliable than JSON tool calling. Reusable code actions Successful code actions can be saved as discoverable tools with clean interfaces where function signature, data models and docstrings are separated from implementation. Agents can then use these tools in later code actions, preserving behavior as executable tools. The result is tool libraries that evolve as agents work. Agent skills Freeact supports the agentskills.io specification, a lightweight format for extending agent capabilities with specialized knowledge and workflows. Freeact provides skills for saving code actions as tools, enhancing existing tools, and structured task planning. Progressive loading Tool and skill information is loaded in stages as needed, rather than consuming context upfront. For tools: category names, tool names, and API definitions load progressively as needed. For skills: metadata loads at startup; full instructions load when triggered. Sandbox mode Code actions execute locally in a stateful IPython kernel via ipybox. Sandbox mode restricts filesystem and network access for executed code (example). Stdio MCP servers can be sandboxed independently. Unified approval Code actions, programmatic tool calls, and JSON-based tool calls all require approval before proceeding. Unified approval ensures every action can be inspected and gated with a uniform interface regardless of how it originates. Python ecosystem Agents can use any Python package available in the execution environment, from data processing with <code>pandas</code> to visualization with <code>matplotlib</code> to HTTP requests with <code>httpx</code>. Many capabilities like data transformation or scientific computing don't need to be wrapped as tools when agents can call libraries directly."},{"location":"#beyond-task-execution","title":"Beyond task execution","text":"<p>Most agents focus on either software development (coding agents) or on non-coding task execution using predefined tools, but not both. Freeact covers a wider range of this spectrum, from task execution to tool development. Its primary function is executing code actions with programmatic tool calling, guided by user instructions and custom skills. </p> <p>Beyond task execution, freeact can save successful code actions as reusable tools or enhance existing tools, acting as a toolsmith in its workspace<sup>2</sup>. For heavier tool engineering like refactoring or reducing tool overlap, freeact is complemented by coding agents like Claude Code, Gemini CLI, etc. Currently the toolsmith role is interactive, with autonomous tool library evolution planned for future versions.</p> <ol> <li> <p>Freeact also supports JSON-based tool calls on MCP servers, but mainly for internal operations.\u00a0\u21a9</p> </li> <li> <p>A workspace is an agent's working directory where it manages tools, skills, configuration and other resources.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"cli/","title":"CLI tool","text":"<p>The <code>freeact</code> or <code>freeact run</code> command starts the interactive mode:</p> <pre><code>freeact\n</code></pre> <p>A <code>.freeact/</code> configuration directory is created automatically if it does not exist yet. The <code>init</code> subcommand initializes the configuration directory without starting the interactive mode:</p> <pre><code>freeact init\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"Option Description <code>--sandbox</code> Run code execution in sandbox mode. <code>--sandbox-config PATH</code> Path to sandbox configuration file. <code>--log-level LEVEL</code> Set logging level: <code>debug</code>, <code>info</code> (default), <code>warning</code>, <code>error</code>, <code>critical</code>. <code>--record</code> Record the conversation as SVG and HTML files. <code>--record-dir PATH</code> Output directory for recordings (default: <code>output</code>). <code>--record-title TEXT</code> Title for the recording (default: <code>Conversation</code>)."},{"location":"cli/#examples","title":"Examples","text":"<p>Running code execution in sandbox mode:</p> <pre><code>freeact --sandbox\n</code></pre> <p>Running with a custom sandbox configuration:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>Recording a session for documentation:</p> <pre><code>freeact --record --record-dir docs/recordings/demo --record-title \"Demo Session\"\n</code></pre>"},{"location":"cli/#interactive-mode","title":"Interactive Mode","text":"<p>The interactive mode provides a conversation interface with the agent in a terminal window.</p> <p></p>"},{"location":"cli/#user-messages","title":"User messages","text":"Key Action <code>Enter</code> Send message <code>Option+Enter</code> (macOS)<code>Alt+Enter</code> (Linux/Windows) Insert newline <code>q</code> + <code>Enter</code> Quit"},{"location":"cli/#image-attachments","title":"Image Attachments","text":"<p>Reference images using <code>@path</code> syntax:</p> <pre><code>@screenshot.png What does this show?\n@images/ Describe these images\n</code></pre> <ul> <li>Single file: <code>@path/to/image.png</code></li> <li>Directory: <code>@path/to/dir/</code> includes all images in directory, non-recursive</li> <li>Supported formats: PNG, JPG, JPEG, GIF, WEBP</li> <li>Tab completion available for paths</li> </ul> <p>Images are automatically downscaled if larger than 1024 pixels in either dimension.</p>"},{"location":"cli/#approval-prompt","title":"Approval Prompt","text":"<p>Before executing code actions or tool calls, the agent requests approval:</p> <pre><code>Approve? [Y/n/a/s]:\n</code></pre> Response Effect <code>Y</code> or <code>Enter</code> Approve once <code>n</code> Reject once (ends the current agent turn) <code>a</code> Approve always (persists to <code>.freeact/permissions.json</code>) <code>s</code> Approve for current session <p>See Permissions API for details.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Freeact configuration is stored in the <code>.freeact/</code> directory. This page describes the directory structure and configuration formats. It also describes the structure of tool directories.</p>"},{"location":"configuration/#initialization","title":"Initialization","text":"<p>The <code>.freeact/</code> directory is created and populated from bundled templates through three entry points:</p> Entry Point Description <code>freeact</code> or <code>freeact run</code> Creates config with CLI tool before starting the agent <code>freeact init</code> Creates config with CLI tool without starting the agent <code>init_config()</code> Creates config programmatically without starting the agent <p>All three entry points share the same behavior:</p> <ul> <li>Missing files are created from default templates</li> <li>Existing files are preserved and never overwritten</li> <li>User modifications persist across restarts and updates</li> </ul> <p>This allows safe customization: edit any configuration file, and your changes remain intact. If you delete a file, it is recreated from the default template on next initialization.</p>"},{"location":"configuration/#directory-structure","title":"Directory Structure","text":"<pre><code>.freeact/\n\u251c\u2500\u2500 prompts/\n\u2502   \u2514\u2500\u2500 system.md        # System prompt template\n\u251c\u2500\u2500 servers.json         # MCP server configurations\n\u251c\u2500\u2500 skills/              # Agent skills\n\u2502   \u2514\u2500\u2500 &lt;skill-name&gt;/\n\u2502       \u251c\u2500\u2500 SKILL.md     # Skill metadata and instructions\n\u2502       \u2514\u2500\u2500 ...          # Further skill resources\n\u251c\u2500\u2500 plans/               # Task plan storage\n\u2514\u2500\u2500 permissions.json     # Persisted approval decisions\n</code></pre>"},{"location":"configuration/#mcp-server-configuration","title":"MCP Server Configuration","text":"<p>The <code>servers.json</code> file configures two types of MCP servers:</p> <pre><code>{\n  \"mcp-servers\": {\n    \"server-name\": { ... }\n  },\n  \"ptc-servers\": {\n    \"server-name\": { ... }\n  }\n}\n</code></pre> <p>Both sections support stdio servers and streamable HTTP servers.</p>"},{"location":"configuration/#mcp-servers","title":"<code>mcp-servers</code>","text":"<p>These are MCP servers that are called directly via JSON. This section is primarily for freeact-internal servers. The default configuration includes the bundled <code>pytools</code> MCP server (for tool discovery) and the <code>filesystem</code> MCP server:</p> <pre><code>{\n  \"mcp-servers\": {\n    \"pytools\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"freeact.agent.tools.pytools.search\"]\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"]\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/#ptc-servers","title":"<code>ptc-servers</code>","text":"<p>These are MCP servers called programmatically via Python APIs. Python APIs must be generated from <code>ptc-servers</code> to <code>mcptools/&lt;server-name&gt;/&lt;tool&gt;.py</code> before the agent can use them. The CLI tool handles this automatically. When using the Python SDK, call <code>generate_mcp_sources()</code> explicitly. Code actions can then import and call the generated APIs.</p> <p>The default configuration includes the bundled <code>google</code> MCP server (web search via Gemini):</p> <pre><code>{\n  \"ptc-servers\": {\n    \"google\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"freeact.agent.tools.gsearch\", \"--thinking-level\", \"medium\"],\n      \"env\": {\"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Custom MCP servers</p> <p>Application-specific MCP servers can be added as needed to <code>ptc-servers</code> for programmatic tool calling.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Server configurations support environment variable references using <code>${VAR_NAME}</code> syntax. <code>Config()</code> validates that all referenced variables are set. If a variable is missing, loading fails with an error.</p>"},{"location":"configuration/#system-prompt","title":"System Prompt","text":"<p>The system prompt template is stored in <code>.freeact/prompts/system.md</code>. The template supports placeholders:</p> Placeholder Description <code>{working_dir}</code> The agent's workspace directory <code>{skills}</code> Rendered metadata from skills in <code>.freeact/skills/</code> <p>See the default template for details.</p> <p>Custom system prompt</p> <p>The system prompt can be extended or modified to specialize agent behavior for specific applications.</p>"},{"location":"configuration/#skills","title":"Skills","text":"<p>Skills are filesystem-based capability packages that specialize agent behavior. A skill is a directory containing a <code>SKILL.md</code> file with metadata in YAML frontmatter, and optionally further skill resources. Skills follow the agentskills.io specification.</p>"},{"location":"configuration/#bundled-skills","title":"Bundled Skills","text":"<p>Freeact contributes three skills to <code>.freeact/skills/</code>:</p> Skill Description output-parsers Generate output parsers for <code>mcptools/</code> with unstructured return types saving-codeacts Save generated code actions as reusable tools in <code>gentools/</code> task-planning Basic task planning and tracking workflows <p>Custom agent skills</p> <p>Custom skills can be added as needed to specialize agent behavior for specific applications.</p>"},{"location":"configuration/#permissions","title":"Permissions","text":"<p>Tool permissions are stored in <code>.freeact/permissions.json</code> based on tool name:</p> <pre><code>{\n  \"allowed_tools\": [\n    \"tool_name_1\",\n    \"tool_name_2\"\n  ]\n}\n</code></pre> <p>Tools in <code>allowed_tools</code> are auto-approved by the CLI tool without prompting. Selecting <code>\"a\"</code> at the approval prompt adds the tool to this list.</p>"},{"location":"configuration/#tool-directories","title":"Tool Directories","text":"<p>The agent discovers tools from two directories:</p>"},{"location":"configuration/#mcptools","title":"<code>mcptools/</code>","text":"<p>Generated Python APIs from <code>ptc-servers</code> schemas:</p> <pre><code>mcptools/\n\u2514\u2500\u2500 &lt;server-name&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;.py        # Generated tool module\n</code></pre>"},{"location":"configuration/#gentools","title":"<code>gentools/</code>","text":"<p>User-defined tools saved from successful code actions:</p> <pre><code>gentools/\n\u2514\u2500\u2500 &lt;category&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>uv package manager</li> <li>Node.js 20+ (for MCP servers)</li> </ul>"},{"location":"installation/#workspace-setup","title":"Workspace Setup","text":"<p>A workspace is a directory where freeact stores configuration, tools, and other resources. Both setup options below require their own workspace directory.</p>"},{"location":"installation/#option-1-minimal","title":"Option 1: Minimal","text":"<p>The fastest way to get started is using <code>uvx</code>, which keeps the virtual environment separate from the workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact\n</code></pre> <p>This is ideal when you don't need to install additional Python packages in the workspace.</p>"},{"location":"installation/#option-2-with-virtual-environment","title":"Option 2: With Virtual Environment","text":"<p>To create a workspace with its own virtual environment:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuv init --bare --python 3.13\nuv add freeact\n</code></pre> <p>Then run freeact with:</p> <pre><code>uv run freeact\n</code></pre> <p>This approach lets you install additional packages (e.g., <code>uv add pandas</code>) that will be available to the agent.</p>"},{"location":"installation/#api-key","title":"API Key","text":"<p>Freeact uses <code>gemini-3-flash-preview</code> as the default model. Set the API key in your environment:</p> <pre><code>export GEMINI_API_KEY=\"your-api-key\"\n</code></pre> <p>Alternatively, place it in a <code>.env</code> file in the workspace directory:</p> .env<pre><code>GEMINI_API_KEY=your-api-key\n</code></pre>"},{"location":"installation/#sandbox-mode-prerequisites","title":"Sandbox Mode Prerequisites","text":"<p>For running freeact in sandbox mode, install Anthropic's sandbox-runtime:</p> <pre><code>npm install -g @anthropic-ai/sandbox-runtime@0.0.21\n</code></pre> <p>Higher versions should also work, but 0.0.21 is the version used in current tests. </p> <p>Required OS-level packages are:</p>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ripgrep\n</code></pre> <p>macOS uses the native <code>sandbox-exec</code> for process isolation.</p>"},{"location":"installation/#linux","title":"Linux","text":"<pre><code>apt-get install bubblewrap socat ripgrep\n</code></pre> <p>Note</p> <p>Sandboxing on Linux is currently work in progress.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide shows how to run your first task with freeact.</p>"},{"location":"quickstart/#cli-tool","title":"CLI Tool","text":"<p>Freeact provides a CLI tool for running the agent in a terminal. </p>"},{"location":"quickstart/#starting-freeact","title":"Starting Freeact","text":"<p>Create a workspace directory, set your API key, and start the agent:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\necho \"GEMINI_API_KEY=your-api-key\" &gt; .env\nuvx freeact\n</code></pre> <p>See Installation for alternative setup options and sandbox mode prerequisites.</p>"},{"location":"quickstart/#generating-mcp-tool-apis","title":"Generating MCP Tool APIs","text":"<p>On first start, the CLI tool auto-generates Python APIs for configured MCP servers. For example, it creates <code>mcptools/google/web_search.py</code> for the <code>web_search</code> tool of the bundled <code>google</code> MCP server. With the generated Python API, the agent can import and call this tool programmatically. </p> <p>Custom MCP servers</p> <p>For calling the tools of your own MCP servers programmatically, add them to the <code>ptc-servers</code> section in <code>.freeact/servers.json</code>. Freeact auto-generates a Python API for them when the CLI tool starts.</p>"},{"location":"quickstart/#running-a-task","title":"Running a Task","text":"<p>With this setup and a question like </p> <p>who is F1 world champion 2025? </p> <p>the CLI tool should generate an output similar to the following:</p> <p></p> <p>The recorded session demonstrates:</p> <ul> <li>Progressive tool loading: The agent progressively loads tool information: lists categories, lists tools in the <code>google</code> category, then reads the <code>web_search</code> API to understand its parameters.</li> <li>Programmatic tool calling: The agent writes Python code that imports the <code>web_search</code> tool from <code>mcptools.google</code> and calls it programmatically with the user's query.</li> <li>Action approval: The code action and the programmatic <code>web_search</code> tool call are explicitly approved by the user, other tool calls were pre-approved for this example.</li> </ul> <p>The code execution output shows the search result with source URLs. The agent response is a summary of it.</p>"},{"location":"quickstart/#python-sdk","title":"Python SDK","text":"<p>The CLI tool is built on a Python SDK that you can use directly in your applications. The following minimal example shows how to run the same task programmatically, with code actions and tool calls auto-approved:</p> <pre><code>import asyncio\nfrom pathlib import Path\n\nfrom freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nfrom freeact.agent.config import Config, init_config\n\nfrom freeact.agent.tools.pytools.apigen import generate_mcp_sources\n\n\n\nasync def main() -&gt; None:\n    # Initialize .freeact/ config directory if needed\n    init_config()\n\n    # Load configuration from .freeact/\n    config = Config()\n\n    # Generate Python APIs for MCP servers in ptc_servers\n    for server_name, params in config.ptc_servers.items():\n        if not Path(f\"mcptools/{server_name}\").exists():\n            await generate_mcp_sources({server_name: params})\n\n    async with Agent(\n        model=config.model,\n        model_settings=config.model_settings,\n        system_prompt=config.system_prompt,\n        mcp_servers=config.mcp_servers,\n    ) as agent:\n        prompt = \"Who is the F1 world champion 2025?\"\n\n        async for event in agent.stream(prompt):\n            match event:\n                case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                    print(f\"Code action:\\n{args['code']}\")\n                    request.approve(True)\n                case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                    print(f\"Tool: {name}\")\n                    print(f\"Args: {args}\")\n                    request.approve(True)\n                case Thoughts(content=content):\n                    print(f\"Thinking: {content}\")\n                case CodeExecutionOutput(text=text):\n                    print(f\"Code execution output: {text}\")\n                case ToolOutput(content=content):\n                    print(f\"Tool call result: {content}\")\n                case Response(content=content):\n                    print(content)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"sandbox/","title":"Sandbox Mode","text":"<p>Freeact can restrict filesystem and network access for code execution and MCP servers using ipybox sandbox and Anthropic's sandbox-runtime.</p> <p>Prerequisites</p> <p>Check the installation instructions for sandbox mode prerequisites.</p>"},{"location":"sandbox/#code-execution","title":"Code Execution","text":""},{"location":"sandbox/#cli-tool","title":"CLI Tool","text":"<p>The <code>--sandbox</code> option enables sandboxed code execution:</p> <pre><code>freeact --sandbox\n</code></pre> <p>A custom configuration file can override the default restrictions:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre>"},{"location":"sandbox/#python-sdk","title":"Python SDK","text":"<p>The <code>sandbox</code> and <code>sandbox_config</code> parameters of the <code>Agent</code> constructor provide the same functionality:</p> <pre><code>from pathlib import Path\n\nagent = Agent(\n    ...\n    sandbox=True,\n    sandbox_config=Path(\"sandbox-config.json\"),\n)\n</code></pre>"},{"location":"sandbox/#default-restrictions","title":"Default Restrictions","text":"<p>Without a custom configuration file, sandbox mode applies these defaults:</p> <ul> <li>Filesystem: Read all files except <code>.env</code>, write to current directory and subdirectories</li> <li>Network: Internet access blocked, local network access to tool execution server permitted</li> </ul>"},{"location":"sandbox/#custom-configuration","title":"Custom Configuration","text":"sandbox-config.json<pre><code>{\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This macOS-specific example configuration allows additional network access to <code>example.org</code>. Filesystem settings permit writes to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code>, which is required for running a sandboxed IPython kernel. The sandbox configuration file itself is protected from reads and writes.</p>"},{"location":"sandbox/#mcp-servers","title":"MCP Servers","text":"<p>MCP servers run as separate processes and are not affected by code execution sandboxing. Local stdio servers can be sandboxed independently by wrapping the server command with the <code>srt</code> tool from sandbox-runtime. This applies to both <code>mcp-servers</code> and <code>ptc-servers</code> in the MCP server configuration.</p>"},{"location":"sandbox/#filesystem-mcp-server","title":"Filesystem MCP Server","text":"<p>This example shows a sandboxed filesystem MCP server in the <code>mcp-servers</code> section:</p> .freeact/servers.json<pre><code>{\n  \"mcp-servers\": {\n    \"filesystem\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-filesystem-mcp.json\",\n        \"npx\", \"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and allows network access to the npm registry, which is required for <code>npx</code> to download the server package:</p> sandbox-filesystem-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sandbox/#fetch-mcp-server","title":"Fetch MCP Server","text":"<p>This example shows a sandboxed fetch MCP server. First, install it locally with:</p> <pre><code>uv add mcp-server-fetch\nuv add \"httpx[socks]&gt;=0.28.1\"\n</code></pre> <p>Then add it to the <code>ptc-servers</code> section:</p> .freeact/servers.json<pre><code>{\n  \"ptc-servers\": {\n    \"fetch\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-fetch-mcp.json\",\n        \"python\", \"-m\", \"mcp_server_fetch\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and restricts the MCP server to fetch only from <code>example.com</code>. Access to the npm registry is required for the server's internal operations:</p> sandbox-fetch-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\", \"/tmp/**\", \"/private/tmp/**\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\", \"example.com\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sdk/","title":"Python SDK","text":"<p>The Python SDK provides four main APIs:</p> <ul> <li>Configuration API for initializing and loading configuration from <code>.freeact/</code></li> <li>Generation API for generating Python APIs for MCP server tools</li> <li>Agent API for running the agentic code action loop</li> <li>Permissions API for managing approval decisions</li> </ul>"},{"location":"sdk/#configuration-api","title":"Configuration API","text":"<p>Use <code>init_config()</code> to initialize the <code>.freeact/</code> directory from default templates. The <code>Config()</code> constructor loads all configuration from it:</p> <pre><code>from freeact.agent.config import Config, init_config\n\n# Initialize .freeact/ config directory if needed\ninit_config()\n\n# Load configuration from .freeact/\nconfig = Config()\n</code></pre> <p>See the Configuration reference for details on the <code>.freeact/</code> directory structure.</p>"},{"location":"sdk/#generation-api","title":"Generation API","text":"<p>MCP servers configured as <code>ptc-servers</code> in <code>servers.json</code> require Python API generation with <code>generate_mcp_sources()</code> before the agent can call their tools programmatically:</p> <pre><code>from freeact.agent.tools.pytools.apigen import generate_mcp_sources\n\n# Generate Python APIs for MCP servers in ptc_servers\nfor server_name, params in config.ptc_servers.items():\n    if not Path(f\"mcptools/{server_name}\").exists():\n        await generate_mcp_sources({server_name: params})\n</code></pre> <p>Generated APIs are stored as <code>mcptools/&lt;server_name&gt;/&lt;tool&gt;.py</code> modules and persist across agent sessions. After generation, the agent can import them for programmatic tool calling:</p> <pre><code>from mcptools.google.web_search import run, Params\n\nresult = run(Params(query=\"python async tutorial\"))\n</code></pre>"},{"location":"sdk/#agent-api","title":"Agent API","text":"<p>The <code>Agent</code> class implements the agentic code action loop, handling code action generation, code execution, tool calls, and the approval workflow. Each <code>stream()</code> call runs a single agent turn, with the agent managing conversation history across calls. Use <code>stream()</code> to iterate over events and handle them with pattern matching:</p> <pre><code>from freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nasync with Agent(\n    model=config.model,\n    model_settings=config.model_settings,\n    system_prompt=config.system_prompt,\n    mcp_servers=config.mcp_servers,\n) as agent:\n    prompt = \"Who is the F1 world champion 2025?\"\n\n    async for event in agent.stream(prompt):\n        match event:\n            case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                print(f\"Code action:\\n{args['code']}\")\n                request.approve(True)\n            case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                print(f\"Tool: {name}\")\n                print(f\"Args: {args}\")\n                request.approve(True)\n            case Thoughts(content=content):\n                print(f\"Thinking: {content}\")\n            case CodeExecutionOutput(text=text):\n                print(f\"Code execution output: {text}\")\n            case ToolOutput(content=content):\n                print(f\"Tool call result: {content}\")\n            case Response(content=content):\n                print(content)\n</code></pre> <p>For processing output incrementally, match the <code>*Chunk</code> event variants listed below.</p>"},{"location":"sdk/#events","title":"Events","text":"<p>The <code>Agent.stream()</code> method yields events as they occur:</p> Event Description <code>ThoughtsChunk</code> Partial model thoughts (content streaming) <code>Thoughts</code> Complete model thoughts at a given step <code>ResponseChunk</code> Partial model response (content streaming) <code>Response</code> Complete model response <code>ApprovalRequest</code> Pending code action or tool call approval <code>CodeExecutionOutputChunk</code> Partial code execution output (content streaming) <code>CodeExecutionOutput</code> Complete code execution output <code>ToolOutput</code> JSON tool call output"},{"location":"sdk/#approval","title":"Approval","text":"<p>The agent provides a unified approval mechanism. It yields <code>ApprovalRequest</code> for all code actions, programmatic tool calls, and JSON tool calls. Execution is suspended until <code>approve()</code> is called. Calling <code>approve(True)</code> executes the code action or tool call; <code>approve(False)</code> rejects it and ends the current agent turn.</p> <pre><code>async for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            # Inspect the pending action\n            print(f\"Tool: {request.tool_name}\")\n            print(f\"Args: {request.tool_args}\")\n\n            # Approve or reject\n            request.approve(True)\n\n        case Response(content=content):\n            print(content)\n</code></pre> <p>Code action approval</p> <p>For code actions, <code>tool_name</code> is <code>ipybox_execute_ipython_cell</code> and <code>tool_args</code> contains the <code>code</code> to execute.</p>"},{"location":"sdk/#lifecycle","title":"Lifecycle","text":"<p>The agent manages MCP server connections and an IPython kernel via ipybox. On entering the async context manager, the IPython kernel starts and MCP servers configured for JSON tool calling connect. MCP servers configured for programmatic tool calling connect lazily on first tool call.</p> <pre><code>async with Agent(...) as agent:\n    async for event in agent.stream(prompt):\n        ...\n# Connections closed, kernel stopped\n</code></pre> <p>Without using the async context manager:</p> <pre><code>agent = Agent(...)\nawait agent.start()\ntry:\n    async for event in agent.stream(prompt):\n        ...\nfinally:\n    await agent.stop()\n</code></pre>"},{"location":"sdk/#permissions-api","title":"Permissions API","text":"<p>The agent requests approval for each code action and tool call but doesn't remember past decisions. <code>PermissionManager</code> adds memory: <code>allow_always()</code> persists to <code>.freeact/permissions.json</code>, while <code>allow_session()</code> stores in-memory until the session ends:</p> <pre><code>from freeact.permissions import PermissionManager\nfrom ipybox.utils import arun\n\nmanager = PermissionManager()\nawait manager.load()\n\nasync for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            if manager.is_allowed(request.tool_name, request.tool_args):\n                request.approve(True)\n            else:\n                choice = await arun(input, \"Allow? [Y/n/a/s]: \")\n                match choice:\n                    case \"a\":\n                        await manager.allow_always(request.tool_name)\n                        request.approve(True)\n                    case \"s\":\n                        manager.allow_session(request.tool_name)\n                        request.approve(True)\n                    case \"n\":\n                        request.approve(False)\n                    case _:\n                        request.approve(True)\n</code></pre>"},{"location":"api/agent/","title":"Agent","text":""},{"location":"api/agent/#freeact.agent.Agent","title":"freeact.agent.Agent","text":"<pre><code>Agent(\n    model: str | Model,\n    model_settings: ModelSettings,\n    system_prompt: str,\n    mcp_servers: dict[str, MCPServer] | None = None,\n    kernel_env: dict[str, str] | None = None,\n    sandbox: bool = False,\n    sandbox_config: Path | None = None,\n    images_dir: Path | None = None,\n)\n</code></pre> <p>Code action agent that generates and executes Python code in ipybox.</p> <p>The agent fulfills user requests by writing Python code and running it in a sandboxed IPython kernel where variables persist across executions. Tools can be called in two ways:</p> <ul> <li>JSON tool calls: MCP servers called directly via structured arguments</li> <li>Programmatic tool calls (PTC): Agent writes Python code that imports   and calls tool APIs. These can be auto-generated from MCP schemas   (<code>mcptools/</code>) or user-defined (<code>gentools/</code>).</li> </ul> <p>All tool executions require approval. The <code>stream()</code> method yields <code>ApprovalRequest</code> events that must be resolved before execution proceeds.</p> <p>Use as an async context manager or call <code>start()</code>/<code>stop()</code> explicitly.</p> <p>Initialize the agent.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str | Model</code> <p>LLM model identifier or pydantic-ai Model instance.</p> required <code>model_settings</code> <code>ModelSettings</code> <p>Temperature, max tokens, and other model params.</p> required <code>system_prompt</code> <code>str</code> <p>Instructions defining agent behavior.</p> required <code>mcp_servers</code> <code>dict[str, MCPServer] | None</code> <p>Named MCP servers for JSON-based tool calls.</p> <code>None</code> <code>kernel_env</code> <code>dict[str, str] | None</code> <p>Environment variables passed to the IPython kernel.</p> <code>None</code> <code>sandbox</code> <code>bool</code> <p>Run the kernel in sandbox mode.</p> <code>False</code> <code>sandbox_config</code> <code>Path | None</code> <p>Path to custom sandbox configuration.</p> <code>None</code> <code>images_dir</code> <code>Path | None</code> <p>Directory for saving generated images.</p> <code>None</code>"},{"location":"api/agent/#freeact.agent.Agent.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the code executor and connect to MCP servers.</p> <p>Automatically called when entering the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the code executor and disconnect from MCP servers.</p> <p>Automatically called when exiting the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    prompt: str | Sequence[UserContent],\n) -&gt; AsyncIterator[\n    ApprovalRequest\n    | ToolOutput\n    | CodeExecutionOutputChunk\n    | CodeExecutionOutput\n    | ThoughtsChunk\n    | Thoughts\n    | ResponseChunk\n    | Response\n]\n</code></pre> <p>Run a full agentic turn, yielding events as they occur.</p> <p>Loops through model responses and tool executions until the model produces a response without tool calls. Both JSON-based and programmatic tool calls yield an <code>ApprovalRequest</code> that must be resolved before execution proceeds.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str | Sequence[UserContent]</code> <p>User message as text or multimodal content sequence.</p> required <p>Returns:</p> Type Description <code>AsyncIterator[ApprovalRequest | ToolOutput | CodeExecutionOutputChunk | CodeExecutionOutput | ThoughtsChunk | Thoughts | ResponseChunk | Response]</code> <p>An async event iterator.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest","title":"freeact.agent.ApprovalRequest  <code>dataclass</code>","text":"<pre><code>ApprovalRequest(\n    tool_name: str,\n    tool_args: dict[str, Any],\n    _future: Future[bool] = Future(),\n)\n</code></pre> <p>Pending tool execution awaiting user approval.</p> <p>Yielded by <code>Agent.stream()</code> before executing any tool. The agent is suspended until <code>approve()</code> is called.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approve","title":"approve","text":"<pre><code>approve(decision: bool) -&gt; None\n</code></pre> <p>Resolve this approval request.</p> <p>Parameters:</p> Name Type Description Default <code>decision</code> <code>bool</code> <p><code>True</code> to allow execution, <code>False</code> to reject.</p> required"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approved","title":"approved  <code>async</code>","text":"<pre><code>approved() -&gt; bool\n</code></pre> <p>Await until <code>approve()</code> is called and return the decision.</p>"},{"location":"api/agent/#freeact.agent.Response","title":"freeact.agent.Response  <code>dataclass</code>","text":"<pre><code>Response(content: str)\n</code></pre> <p>Complete model text response after streaming finishes.</p>"},{"location":"api/agent/#freeact.agent.ResponseChunk","title":"freeact.agent.ResponseChunk  <code>dataclass</code>","text":"<pre><code>ResponseChunk(content: str)\n</code></pre> <p>Partial text from an in-progress model response.</p>"},{"location":"api/agent/#freeact.agent.Thoughts","title":"freeact.agent.Thoughts  <code>dataclass</code>","text":"<pre><code>Thoughts(content: str)\n</code></pre> <p>Complete model thoughts after streaming finishes.</p>"},{"location":"api/agent/#freeact.agent.ThoughtsChunk","title":"freeact.agent.ThoughtsChunk  <code>dataclass</code>","text":"<pre><code>ThoughtsChunk(content: str)\n</code></pre> <p>Partial text from model's extended thinking.</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutput","title":"freeact.agent.CodeExecutionOutput  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutput(text: str | None, images: list[Path])\n</code></pre> <p>Complete result from Python code execution in the ipybox kernel.</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutputChunk","title":"freeact.agent.CodeExecutionOutputChunk  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutputChunk(text: str)\n</code></pre> <p>Partial output from an in-progress code execution.</p>"},{"location":"api/agent/#freeact.agent.ToolOutput","title":"freeact.agent.ToolOutput  <code>dataclass</code>","text":"<pre><code>ToolOutput(content: ToolResult)\n</code></pre> <p>Result from a JSON-based MCP tool call.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#freeact.agent.config.Config","title":"freeact.agent.config.Config","text":"<pre><code>Config(\n    working_dir: Path | None = None,\n    model: str | Model = DEFAULT_MODEL,\n    model_settings: ModelSettings = DEFAULT_MODEL_SETTINGS,\n)\n</code></pre> <p>Configuration loader for the <code>.freeact/</code> directory structure.</p> <p>Loads and parses all configuration on instantiation: skills metadata, system prompts, MCP servers (JSON tool calls), and PTC servers (programmatic tool calling).</p> <p>Attributes:</p> Name Type Description <code>working_dir</code> <p>Agent's working directory.</p> <code>freeact_dir</code> <p>Path to <code>.freeact/</code> configuration directory.</p> <code>plans_dir</code> <p>Path to <code>.freeact/plans/</code> for plan storage.</p> <code>model</code> <p>LLM model name or instance.</p> <code>model_settings</code> <p>Model-specific settings (e.g., thinking config).</p> <code>skills_metadata</code> <p>Parsed skill definitions from <code>.freeact/skills/*/SKILL.md</code>.</p> <code>system_prompt</code> <p>Rendered system prompt from <code>.freeact/prompts/system.md</code>.</p> <code>mcp_servers</code> <p><code>MCPServer</code> instances used for JSON tool calling.</p> <code>ptc_servers</code> <p>Raw PTC server configs for programmatic tool generation.</p>"},{"location":"api/config/#freeact.agent.config.SkillMetadata","title":"freeact.agent.config.SkillMetadata  <code>dataclass</code>","text":"<pre><code>SkillMetadata(name: str, description: str, path: Path)\n</code></pre> <p>Metadata parsed from a skill's SKILL.md frontmatter.</p>"},{"location":"api/config/#freeact.agent.config.init_config","title":"freeact.agent.config.init_config","text":"<pre><code>init_config(working_dir: Path | None = None) -&gt; None\n</code></pre> <p>Initialize <code>.freeact/</code> config directory from templates.</p> <p>Copies template files that don't already exist, preserving user modifications.</p> <p>Parameters:</p> Name Type Description Default <code>working_dir</code> <code>Path | None</code> <p>Base directory. Defaults to current working directory.</p> <code>None</code>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL","title":"freeact.agent.config.DEFAULT_MODEL  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL = 'gemini-3-flash-preview'\n</code></pre>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL_SETTINGS","title":"freeact.agent.config.DEFAULT_MODEL_SETTINGS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL_SETTINGS = GoogleModelSettings(\n    google_thinking_config={\n        \"thinking_level\": \"high\",\n        \"include_thoughts\": True,\n    }\n)\n</code></pre>"},{"location":"api/generate/","title":"Generate","text":""},{"location":"api/generate/#freeact.agent.tools.pytools.apigen.generate_mcp_sources","title":"freeact.agent.tools.pytools.apigen.generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    config: dict[str, dict[str, Any]],\n) -&gt; None\n</code></pre> <p>Generate Python API for MCP servers in <code>config</code>.</p> <p>For servers not already in <code>mcptools/</code> categories, generates Python API using <code>ipybox.generate_mcp_sources</code>.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, dict[str, Any]]</code> <p>Dictionary mapping server names to server configurations.</p> required"},{"location":"api/permissions/","title":"Permissions","text":""},{"location":"api/permissions/#freeact.permissions.PermissionManager","title":"freeact.permissions.PermissionManager","text":"<pre><code>PermissionManager(freeact_dir: Path = Path('.freeact'))\n</code></pre> <p>Tool permission gating with two-tier approval: always-allowed (persisted) and session-only (in-memory).</p> <p>Filesystem tools targeting paths within <code>.freeact/</code> are auto-approved without explicit permission grants.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_always","title":"allow_always  <code>async</code>","text":"<pre><code>allow_always(tool_name: str) -&gt; None\n</code></pre> <p>Grant permanent permission for a tool and persist to disk.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_session","title":"allow_session","text":"<pre><code>allow_session(tool_name: str) -&gt; None\n</code></pre> <p>Grant permission for a tool until the session ends (not persisted).</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.is_allowed","title":"is_allowed","text":"<pre><code>is_allowed(\n    tool_name: str, tool_args: dict[str, Any] | None = None\n) -&gt; bool\n</code></pre> <p>Check if a tool call is pre-approved.</p> <p>Returns <code>True</code> if the tool is in the always-allowed or session-allowed set, or if it's a filesystem tool operating within <code>.freeact/</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.load","title":"load  <code>async</code>","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load always-allowed tools from <code>.freeact/permissions.json</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.save","title":"save  <code>async</code>","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persist always-allowed tools to <code>.freeact/permissions.json</code>.</p>"},{"location":"examples/agent-skills/","title":"Custom Agent Skills","text":"<p>Freeact supports the agentskills.io specification, a lightweight format for extending agent capabilities with specialized knowledge and workflows. Skills that guide code execution are particularly well-suited for freeact's code action approach. Skills are loaded on demand: only metadata is in context initially, full instructions load when relevant.  </p>"},{"location":"examples/agent-skills/#pdf-generation","title":"PDF Generation","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example uses the PDF skill from the Anthropic skills repository, a collection of production-quality skills maintained by Anthropic.</p> <p>Create a workspace with a virtual environment and install the required dependencies for this example:</p> <pre><code>uv pip install reportlab\n</code></pre> <p>Install the PDF skill:</p> <pre><code>git clone https://github.com/anthropics/skills.git /tmp/skills\nmkdir -p .freeact/skills\ncp -r /tmp/skills/skills/pdf .freeact/skills/\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>When asked to</p> <p>calculate compound interest for $10,000 at 5% for 10 years, save result to output/compound_interest.pdf</p> <p>the agent:</p> <ol> <li>Identifies the PDF skill as relevant based on the request to create a PDF document</li> <li>Loads the skill instructions by reading the <code>pdf/SKILL.md</code> file</li> <li>Performs the calculation and generates a PDF following the skill's guidance</li> </ol> <p></p>"},{"location":"examples/output-parser/","title":"Enhancing Tools","text":"<p>Many MCP servers lack output schemas. For example, all tools of the GitHub MCP server return a JSON string without defining an output schema. Without an output schema, the <code>run()</code> function of the generated tool API returns a plain string instead of a structured <code>Result</code> type.</p> <p>Without knowing output structure beforehand, an agent cannot reliably write code that processes tool output inside a code action. It must retrieve raw results into context for inspection, then write processing logic in another inference round.</p> <p>Freeact's bundled <code>output-parsers</code> skill solves this by generating output parsers that enhance tool APIs with a <code>run_parsed()</code> function that returns a structured output type. With output types known, the agent can generate processing logic in a single inference round. </p> <p>This tool enhancement persists across sessions and is an example of the agent acting as a toolsmith, enhancing its own tool library rather than just executing tasks.</p>"},{"location":"examples/output-parser/#output-parser-generation","title":"Output Parser Generation","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>Create a workspace and initialize the configuration directory:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact init\n</code></pre> <p>Add the GitHub MCP server to <code>ptc-servers</code> in <code>.freeact/servers.json</code>:</p> <pre><code>{\n  \"ptc-servers\": {\n    \"github\": {\n      \"url\": \"https://api.githubcopilot.com/mcp/\",\n      \"headers\": {\"Authorization\": \"Bearer ${GITHUB_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Set your GitHub personal access token (PAT) as the <code>GITHUB_API_KEY</code> environment variable or add it to <code>.env</code>. </p> <p>Then start the CLI tool to automatically generate Python APIs to <code>mcptools/github/</code>:</p> <pre><code>uvx freeact\n</code></pre> <p>When asked to </p> <p>create an output parser for search_repositories</p> <p>the agent </p> <ol> <li>Loads the <code>output-parsers</code> skill and the generated <code>search_repositories.py</code> tool API</li> <li>Calls the <code>search_repositories.run()</code> function with example inputs to observe outputs</li> <li>Identifies parseable JSON with fields like <code>name</code>, <code>description</code>, <code>stargazers_count</code>, etc.</li> <li>Creates an enhanced tool API with <code>ParseResult</code>, <code>Repository</code> and <code>run_parsed()</code></li> <li>Saves the parser to a separate <code>mcpparse/github/search_repositories.py</code></li> <li>Resets the IPython kernel to re-import the tool for testing <code>run_parsed()</code></li> </ol> <p></p> <p>The enhanced tool can now be composed with other tools in a single code action, with full type information available for processing intermediate results.</p>"},{"location":"examples/python-packages/","title":"Data analysis","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>Freeact can use any Python package available in the execution environment. This example demonstrates using scikit-learn and matplotlib directly in code actions to fit a Gaussian Process Regressor to noisy sine wave data and visualize the results with uncertainty bounds.</p> <p>Create a workspace with a virtual environment and install the required dependencies:</p> <pre><code>uv pip install scikit-learn matplotlib\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>In the recording below, the agent performs Gaussian Process Regression in response to a single prompt:</p> <p>Generate 30 noisy samples from a sine function and fit a Gaussian process regressor to the data. Save the result as a plot with uncertainty bounds to output/gpr_sine.png.</p> <p>The agent generates the samples, fits a <code>GaussianProcessRegressor</code> with an RBF kernel, and creates a visualization showing the true sine function, noisy samples, model predictions, and uncertainty bounds.</p> <p>A follow-up prompt asks for model statistics:</p> <p>print the stats</p> <p>The agent prints the log-marginal-likelihood and other attributes from the fitted model.</p> <p></p> <p>The resulting plot shows the GPR fit with a confidence interval:</p> <p></p>"},{"location":"examples/sandbox-mode/","title":"Sandbox Mode","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example demonstrates running code execution in sandbox mode with a custom sandbox configuration. It does not cover sandboxing MCP servers.</p> <p>Create a workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\n</code></pre> <p>Create a <code>sandbox-config.json</code> file in your workspace directory:</p> sandbox-config.json<pre><code>{\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This configuration allows network access only to <code>example.org</code> and protects the sandbox config file from being read or modified. The <code>allowLocalBinding</code> and write access to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code> are required for the sandboxed IPython kernel to operate on macOS.</p> <p>Start the CLI tool with the custom sandbox configuration:</p> <pre><code>uvx freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>The recording below demonstrates the sandbox in action. First, the agent can access the allowed domain:</p> <p>use requests to read from example.org, print status code only</p> <p>This succeeds with status <code>200</code>. Other domains are blocked:</p> <p>now from google.com</p> <p>This fails with a <code>403 Forbidden</code>. The sandbox also protects the config file:</p> <p>print the content of sandbox-config.json in a code action</p> <p>This fails with a <code>PermissionError</code>.</p> <p></p>"},{"location":"examples/saving-codeacts/","title":"Code Action Reuse","text":"<p>Any code action can be saved as a discoverable tool, enabling tool libraries to evolve as agents work. Composite code actions that chain multiple tools are a common example.</p> <p>Freeact provides the <code>saving-codeacts</code> skill for saving code actions as reusable tools. It separates interface (<code>api.py</code>) from implementation (<code>impl.py</code>). The interface contains the function signature, Pydantic models, and docstrings. The implementation contains the actual logic. </p> <p>This separation enables efficient tool discovery: agents inspect signatures and docstrings without loading implementation details. The implementation stays hidden, saving tokens and reducing distraction by keeping non-essential details out of context.</p> <p>The following example shows how to compose and save a code action as a parameterized tool, then discover and reuse it in a new session.</p>"},{"location":"examples/saving-codeacts/#compose-and-save","title":"Compose and Save","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example continues from the enhancing tools example, where <code>search_repositories</code> was augmented with a <code>run_parsed()</code> function returning typed <code>Repository</code> objects. In the same workspace, start a new CLI tool session with:</p> <pre><code>uvx freeact\n</code></pre> <p>With a query like</p> <p>get the latest 5 commits of the 3 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers <code>search_repositories</code> and <code>list_commits</code> as appropriate tools and inspects their APIs. Because the enhanced <code>search_repositories</code> tool now returns typed output via <code>run_parsed()</code>, the agent can compose these tools in a single code action, passing repository names from search results as input to <code>list_commits</code><sup>1</sup>.</p> <p>After code action execution, we instruct the agent to save it as a reusable tool:</p> <p>save this as tool under category github, with username, top_n_repos, top_n_commits as parameter</p> <p>The agent:</p> <ol> <li>Loads the <code>saving-codeacts</code> skill</li> <li>Creates a <code>gentools/github/commits_of_top_repos/</code> package</li> <li>Saves the tool API with a parameterized <code>run()</code> function to <code>api.py</code></li> <li>Saves the implementation to <code>impl.py</code>, lazily imported by <code>run()</code></li> <li>Tests the saved tool to verify it works</li> </ol> <p>The structure of the saved tool is:</p> <pre><code>gentools/\n\u2514\u2500\u2500 github/\n    \u2514\u2500\u2500 commits_of_top_repos/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre> <p></p>"},{"location":"examples/saving-codeacts/#discover-and-reuse","title":"Discover and Reuse","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>In a new session, the saved tool is discovered like any other Python tool. During discovery, only the API is inspected, not the implementation. When asked to</p> <p>get the latest 3 commits of the 2 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers the previously saved tool, inspects its API, and calls it with different parameters (<code>top_n_repos=2</code>, <code>top_n_commits=3</code>).</p> <p></p> <ol> <li> <p>Since <code>list_commits</code> doesn't return typed output, the agent guesses output structure from training data, which may or may not work on first attempt. This can be made more reliable by also generating an output parser for <code>list_commits</code>.\u00a0\u21a9</p> </li> </ol>"}]}