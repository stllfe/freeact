{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Freeact is a lightweight agent that acts by executing Python code and shell commands. Code actions are key for an agent to improve its own tool library and codebase.</p> <p>Freeact has a tiny core, a small system prompt, and is extensible with agent skills. It relies on a minimal set of generic tools: read, write, execute, subagent, and tool search.</p> <p>Code and shell command execution runs locally in a stateful, sandboxed environment. Freeact supports utilization of MCP servers by generating Python APIs for their tools.</p> <p>Supported models</p> <p>Freeact supports models compatible with Pydantic AI, with <code>gemini-3-flash-preview</code> as the current default.</p>"},{"location":"#usage","title":"Usage","text":"Component Description Agent SDK Agent harness and Python API for building freeact applications. CLI tool Terminal interface for interactive conversations with a freeact agent."},{"location":"#capabilities","title":"Capabilities","text":"Capability Description Code actions Freeact agents act via Python code and shell commands. This enables tool composition and intermediate result processing in a single LLM inference pass. Local execution Freeact executes code and shell commands locally in an IPython kernel provided by ipybox. Data, configuration and generated tools live in local workspaces. Sandbox mode IPython kernels optionally run in a sandbox environment based on Anthropic's sandbox-runtime. It enforces filesystem and network restrictions on OS-level. MCP code mode Freeact calls MCP server tools programmatically<sup>1</sup> via generated Python APIs. This enables composition of tool calls in code actions with much lower latency. Tool discovery Tools are discovered via category browsing or hybrid BM25/vector search. On-demand loading frees the context window and scales to larger tool libraries. Tool authoring Agents can create new tools, enhance existing tools, or save code actions as reusable tools. This captures successful experience as executable knowledge. Agent skills Skills give agents new capabilities and expertise based on agentskills.io. They compose naturally with code actions and agent-authored tools. Subagent delegation Tasks can be delegated to subagents, each using their own sandbox. It enables specialization and parallelization without cluttering the main agent's context. Action approval Fine-grained approval of code actions and (programmatic) tool calls from both main agents and subagents. Enables human control over potentially risky actions. Session persistence Freeact persists agent state incrementally. Persisted sessions can be resumed and serve as a record for debugging, evaluation, and improvement. <ol> <li> <p>Freeact also supports MCP server integration via JSON tool calling but the recommended approach is programmatic tool calling.\u00a0\u21a9</p> </li> </ol>"},{"location":"cli/","title":"CLI tool","text":"<p>Work in progress</p> <p>The terminal interface is preliminary and will be reimplemented in a future release.</p> <p>The <code>freeact</code> or <code>freeact run</code> command starts the interactive mode:</p> <pre><code>freeact\n</code></pre> <p>A <code>.freeact/</code> configuration directory is created automatically if it does not exist yet. The <code>init</code> subcommand initializes the configuration directory without starting the interactive mode:</p> <pre><code>freeact init\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"Option Description <code>--sandbox</code> Run code execution in sandbox mode. <code>--sandbox-config PATH</code> Path to sandbox configuration file. <code>--session-id UUID</code> Resume a previous session by its UUID. Generates a new UUID if omitted. <code>--log-level LEVEL</code> Set logging level: <code>debug</code>, <code>info</code> (default), <code>warning</code>, <code>error</code>, <code>critical</code>. <code>--record</code> Record the conversation as SVG and HTML files. <code>--record-dir PATH</code> Output directory for recordings (default: <code>output</code>). <code>--record-title TEXT</code> Title for the recording (default: <code>Conversation</code>)."},{"location":"cli/#examples","title":"Examples","text":"<p>Running code execution in sandbox mode:</p> <pre><code>freeact --sandbox\n</code></pre> <p>Running with a custom sandbox configuration:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>Resuming a previous session:</p> <pre><code>freeact --session-id 550e8400-e29b-41d4-a716-446655440000\n</code></pre> <p>Recording a session for documentation:</p> <pre><code>freeact --record --record-dir docs/recordings/demo --record-title \"Demo Session\"\n</code></pre>"},{"location":"cli/#interactive-mode","title":"Interactive Mode","text":"<p>The interactive mode provides a conversation interface with the agent in a terminal window.</p> <p></p>"},{"location":"cli/#user-messages","title":"User messages","text":"Key Action <code>Enter</code> Send message <code>Option+Enter</code> (macOS)<code>Alt+Enter</code> (Linux/Windows) Insert newline <code>q</code> + <code>Enter</code> Quit"},{"location":"cli/#image-attachments","title":"Image Attachments","text":"<p>Reference images using <code>@path</code> syntax:</p> <pre><code>@screenshot.png What does this show?\n@images/ Describe these images\n</code></pre> <ul> <li>Single file: <code>@path/to/image.png</code></li> <li>Directory: <code>@path/to/dir/</code> includes all images in directory, non-recursive</li> <li>Supported formats: PNG, JPG, JPEG, GIF, WEBP</li> <li>Tab completion available for paths</li> </ul> <p>Images are automatically downscaled if larger than 1024 pixels in either dimension.</p>"},{"location":"cli/#approval-prompt","title":"Approval Prompt","text":"<p>Before executing code actions or tool calls, the agent requests approval:</p> <pre><code>Approve? [Y/n/a/s]:\n</code></pre> Response Effect <code>Y</code> or <code>Enter</code> Approve once <code>n</code> Reject once (ends the current agent turn) <code>a</code> Approve always (persists to <code>.freeact/permissions.json</code>) <code>s</code> Approve for current session <p>See Permissions API for details.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Freeact configuration is stored in the <code>.freeact/</code> directory. This page describes the directory structure and configuration formats. It also describes the structure of tool directories.</p>"},{"location":"configuration/#initialization","title":"Initialization","text":"<p>The <code>.freeact/</code> directory is created and populated from bundled templates through three entry points:</p> Entry Point Description <code>freeact</code> or <code>freeact run</code> Creates config with CLI tool before starting the agent <code>freeact init</code> Creates config with CLI tool without starting the agent <code>Config.init()</code> Creates config programmatically without starting the agent <p>All three entry points share the same behavior:</p> <ul> <li>Missing files are created from default templates</li> <li>Existing files are preserved and never overwritten</li> <li>User modifications persist across restarts and updates</li> </ul> <p>This allows safe customization: edit any configuration file, and your changes remain intact. If you delete a file, it is recreated from the default template on next initialization.</p>"},{"location":"configuration/#directory-structure","title":"Directory Structure","text":"<pre><code>.freeact/\n\u251c\u2500\u2500 config.json         # Configuration and MCP server definitions\n\u251c\u2500\u2500 skills/             # Agent skills\n\u2502   \u2514\u2500\u2500 &lt;skill-name&gt;/\n\u2502       \u251c\u2500\u2500 SKILL.md    # Skill metadata and instructions\n\u2502       \u2514\u2500\u2500 ...         # Further skill resources\n\u251c\u2500\u2500 generated/          # Generated tool sources (on PYTHONPATH)\n\u2502   \u251c\u2500\u2500 mcptools/       # Generated Python APIs from ptc-servers\n\u2502   \u2514\u2500\u2500 gentools/       # User-defined tools saved from code actions\n\u251c\u2500\u2500 plans/              # Task plan storage\n\u251c\u2500\u2500 sessions/           # Session trace storage\n\u2502   \u2514\u2500\u2500 &lt;session-uuid&gt;/\n\u2502       \u251c\u2500\u2500 main.jsonl\n\u2502       \u2514\u2500\u2500 sub-xxxx.jsonl\n\u2514\u2500\u2500 permissions.json    # Persisted approval decisions\n</code></pre>"},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>The <code>config.json</code> file contains agent settings and MCP server configurations:</p> <pre><code>{\n  \"tool-search\": \"basic\",\n  \"images-dir\": null,\n  \"execution-timeout\": 300,\n  \"approval-timeout\": null,\n  \"enable-subagents\": true,\n  \"max-subagents\": 5,\n  \"kernel-env\": {},\n  \"mcp-servers\": {},\n  \"ptc-servers\": {\n    \"server-name\": { ... }\n  }\n}\n</code></pre>"},{"location":"configuration/#agent-settings","title":"Agent Settings","text":"Setting Default Description <code>images-dir</code> <code>null</code> Directory for saving generated images to disk. <code>null</code> defaults to <code>images</code> in the working directory. <code>execution-timeout</code> <code>300</code> Maximum time in seconds for code execution. Approval wait time is excluded. <code>null</code> means no timeout. <code>approval-timeout</code> <code>null</code> Timeout in seconds for PTC approval requests. <code>null</code> means no timeout. <code>enable-subagents</code> <code>true</code> Whether to enable subagent delegation <code>max-subagents</code> <code>5</code> Maximum number of concurrent subagents <code>kernel-env</code> <code>{}</code> Environment variables passed to the IPython kernel. Supports <code>${VAR}</code> placeholders resolved against the host environment."},{"location":"configuration/#tool-search","title":"<code>tool-search</code>","text":"<p>Controls how the agent discovers Python tools:</p> Mode Description <code>basic</code> Category browsing with <code>pytools_list_categories</code> and <code>pytools_list_tools</code> <code>hybrid</code> BM25/vector search with <code>pytools_search_tools</code> for natural language queries <p>The <code>tool-search</code> setting also selects the matching system prompt template (see System Prompt). For hybrid mode environment variables, see Hybrid Search.</p>"},{"location":"configuration/#mcp-servers","title":"<code>mcp-servers</code>","text":"<p>MCP servers called directly via JSON tool calls. Internal servers (<code>pytools</code> for basic or hybrid tool search and <code>filesystem</code> for file operations) are provided automatically and do not need to be configured. User-defined servers in this section are merged with the internal defaults. If a user entry uses the same key as an internal server, the user entry takes precedence.</p> <p>Custom MCP servers</p> <p>Application-specific MCP servers for JSON tool calls can be added to this section as needed.</p>"},{"location":"configuration/#ptc-servers","title":"<code>ptc-servers</code>","text":"<p>MCP servers called programmatically via generated Python APIs. This is freeact's implementation of code mode<sup>1</sup>, where the agent calls MCP tools by writing code against generated APIs rather than through JSON tool calls. This allows composing multiple tool calls, processing intermediate results, and using control flow within a single code action.</p> <p>Python APIs must be generated from <code>ptc-servers</code> to <code>.freeact/generated/mcptools/&lt;server-name&gt;/&lt;tool&gt;.py</code> before the agent can use them. The CLI tool handles this automatically. When using the Agent SDK, call <code>generate_mcp_sources()</code> explicitly. Code actions can then import and call the generated APIs because <code>.freeact/generated/</code> is on the kernel's <code>PYTHONPATH</code>.</p> <p>The default configuration includes the bundled <code>google</code> MCP server (web search via Gemini):</p> <pre><code>{\n  \"ptc-servers\": {\n    \"google\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"freeact.tools.gsearch\", \"--thinking-level\", \"medium\"],\n      \"env\": {\"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Custom MCP servers</p> <p>Application-specific MCP servers can be added as needed to <code>ptc-servers</code> for programmatic tool calling.</p>"},{"location":"configuration/#server-formats","title":"Server Formats","text":"<p>Both <code>mcp-servers</code> and <code>ptc-servers</code> support stdio servers and streamable HTTP servers.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Server configurations support environment variable references using <code>${VAR_NAME}</code> syntax. <code>Config()</code> validates that all referenced variables are set. If a variable is missing, loading fails with an error.</p>"},{"location":"configuration/#hybrid-search","title":"Hybrid Search","text":"<p>When <code>tool-search</code> is set to <code>\"hybrid\"</code> in <code>config.json</code>, the hybrid search server reads additional configuration from environment variables. Default values are provided for all optional variables:</p> Variable Default Description <code>GEMINI_API_KEY</code> (required) API key for the default embedding model <code>PYTOOLS_DIR</code> <code>.freeact/generated</code> Base directory containing <code>mcptools/</code> and <code>gentools/</code> <code>PYTOOLS_DB_PATH</code> <code>.freeact/search.db</code> Path to SQLite database for search index <code>PYTOOLS_EMBEDDING_MODEL</code> <code>google-gla:gemini-embedding-001</code> Embedding model identifier <code>PYTOOLS_EMBEDDING_DIM</code> <code>3072</code> Embedding vector dimensions <code>PYTOOLS_SYNC</code> <code>true</code> Sync index with tool directories on startup <code>PYTOOLS_WATCH</code> <code>true</code> Watch tool directories for changes <code>PYTOOLS_BM25_WEIGHT</code> <code>1.0</code> Weight for BM25 (keyword) results in hybrid fusion <code>PYTOOLS_VEC_WEIGHT</code> <code>1.0</code> Weight for vector (semantic) results in hybrid fusion <p>To use a different embedding provider, change <code>PYTOOLS_EMBEDDING_MODEL</code> to a supported pydantic-ai embedder identifier.</p> <p>Testing without an API key</p> <p>Set <code>PYTOOLS_EMBEDDING_MODEL=test</code> to use a test embedder that generates deterministic embeddings. This is useful for development and testing but produces meaningless search results.</p>"},{"location":"configuration/#system-prompt","title":"System Prompt","text":"<p>The system prompt is an internal resource bundled with the package. The template used depends on the <code>tool-search</code> setting in <code>config.json</code>:</p> Mode Template Description <code>basic</code> <code>system-basic.md</code> Category browsing with <code>pytools_list_categories</code> and <code>pytools_list_tools</code> <code>hybrid</code> <code>system-hybrid.md</code> Semantic search with <code>pytools_search_tools</code> <p>The template supports placeholders:</p> Placeholder Description <code>{working_dir}</code> The agent's workspace directory <code>{generated_rel_dir}</code> Relative path to the generated tool sources directory <code>{skills}</code> Rendered metadata from skills in <code>.freeact/skills/</code> <p>See the templates for basic and hybrid modes.</p>"},{"location":"configuration/#skills","title":"Skills","text":"<p>Skills are filesystem-based capability packages that specialize agent behavior. A skill is a directory containing a <code>SKILL.md</code> file with metadata in YAML frontmatter, and optionally further skill resources. Skills follow the agentskills.io specification.</p>"},{"location":"configuration/#bundled-skills","title":"Bundled Skills","text":"<p>Freeact contributes three skills to <code>.freeact/skills/</code>:</p> Skill Description output-parsers Generate output parsers for <code>mcptools/</code> with unstructured return types saving-codeacts Save generated code actions as reusable tools in <code>gentools/</code> task-planning Basic task planning and tracking workflows <p>Tool authoring</p> <p>The <code>output-parsers</code> and <code>saving-codeacts</code> skills enable tool authoring. See Enhancing Tools and Code Action Reuse for walkthroughs.</p> <p>Custom agent skills</p> <p>Custom skills can be added as needed to specialize agent behavior for specific applications.</p>"},{"location":"configuration/#permissions","title":"Permissions","text":"<p>Tool permissions are stored in <code>.freeact/permissions.json</code> based on tool name:</p> <pre><code>{\n  \"allowed_tools\": [\n    \"tool_name_1\",\n    \"tool_name_2\"\n  ]\n}\n</code></pre> <p>Tools in <code>allowed_tools</code> are auto-approved by the CLI tool without prompting. Selecting <code>\"a\"</code> at the approval prompt adds the tool to this list.</p>"},{"location":"configuration/#tool-directories","title":"Tool Directories","text":"<p>The agent discovers tools from two directories under <code>.freeact/generated/</code>:</p>"},{"location":"configuration/#mcptools","title":"<code>mcptools/</code>","text":"<p>Generated Python APIs from <code>ptc-servers</code> schemas:</p> <pre><code>.freeact/generated/mcptools/\n\u2514\u2500\u2500 &lt;server-name&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;.py        # Generated tool module\n</code></pre>"},{"location":"configuration/#gentools","title":"<code>gentools/</code>","text":"<p>User-defined tools saved from successful code actions:</p> <pre><code>.freeact/generated/gentools/\n\u2514\u2500\u2500 &lt;category&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre> <ol> <li> <p>Code Mode: the better way to use MCP \u21a9</p> </li> </ol>"},{"location":"execution/","title":"Code Execution","text":"<p>Freeact executes Python code and shell commands in an IPython kernel provided by ipybox. Both run through the same <code>ipybox_execute_ipython_cell</code> internal tool, and the kernel is stateful: variables, imports, and function definitions persist across executions within a session.</p> <p>Python code and shell commands share the same kernel, but shell commands use the <code>!</code> prefix (e.g., <code>!ls</code>, <code>!git status</code>, <code>!uv pip install</code>). The bundled system prompts provide initial guidance on when to use shell commands versus Python code. More detailed guidance can be given in custom agent skills.</p>"},{"location":"execution/#python-code","title":"Python Code","text":"<p>Given a prompt like \"what is 17 raised to the power of 0.13\", the agent generates and executes Python code directly:</p> <p><pre><code>print(17 ** 0.13)\n</code></pre> <pre><code>1.4453011884051326\n</code></pre></p>"},{"location":"execution/#shell-commands","title":"Shell Commands","text":"<p>Given a prompt like \"which .py files in tests/ contain ipybox\", the agent uses a shell command with the <code>!</code> prefix:</p> <p><pre><code>!grep -r \"ipybox\" tests/ --include=\"*.py\" -l\n</code></pre> <pre><code>tests/unit/test_agent.py\ntests/conftest.py\ntests/integration/test_agent.py\ntests/integration/test_subagents.py\n</code></pre></p> <p>Each <code>!</code> line spawns a separate subprocess. Multi-line shell scripts can use the <code>%%bash</code> cell magic, which runs as a single subprocess:</p> <pre><code>%%bash\ncd /tmp\necho \"Now in $(pwd)\"\nls -la\n</code></pre> <p>Shell state (working directory, variables) does not persist across <code>!</code> lines but persists within a <code>%%bash</code> block. Neither carries state to the next cell execution.</p>"},{"location":"execution/#mixing-both","title":"Mixing Both","text":"<p>Python and shell commands can be freely combined within a single code action. A common pattern is installing a package and using it immediately:</p> <pre><code>!uv pip install pandas\nimport pandas as pd\n\ndf = pd.read_csv(\"data.csv\")\nprint(df.describe())\n</code></pre> <p>Shell output can be captured into Python variables:</p> <pre><code>files = !ls /data/*.csv\nprint(f\"Found {len(files)} CSV files\")\n</code></pre> <p>Python variables can be interpolated into shell commands:</p> <pre><code>filename = \"report.pdf\"\n!cp /tmp/{filename} /output/\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>uv package manager</li> <li>Node.js 20+ (for MCP servers)</li> </ul>"},{"location":"installation/#workspace-setup","title":"Workspace Setup","text":"<p>A workspace is a directory where freeact stores configuration, tools, and other resources. Both setup options below require their own workspace directory.</p>"},{"location":"installation/#option-1-minimal","title":"Option 1: Minimal","text":"<p>The fastest way to get started is using <code>uvx</code>, which keeps the virtual environment separate from the workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact\n</code></pre> <p>This is ideal when you don't need to install additional Python packages in the workspace.</p>"},{"location":"installation/#option-2-with-virtual-environment","title":"Option 2: With Virtual Environment","text":"<p>To create a workspace with its own virtual environment:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuv init --bare --python 3.13\nuv add freeact\n</code></pre> <p>Then run freeact with:</p> <pre><code>uv run freeact\n</code></pre> <p>This approach lets you install additional packages (e.g., <code>uv add pandas</code>) that will be available to the agent.</p>"},{"location":"installation/#api-key","title":"API Key","text":"<p>Freeact uses <code>gemini-3-flash-preview</code> as the default model. Set the API key in your environment:</p> <pre><code>export GEMINI_API_KEY=\"your-api-key\"\n</code></pre> <p>Alternatively, place it in a <code>.env</code> file in the workspace directory:</p> .env<pre><code>GEMINI_API_KEY=your-api-key\n</code></pre>"},{"location":"installation/#sandbox-mode-prerequisites","title":"Sandbox Mode Prerequisites","text":"<p>For running freeact in sandbox mode, install Anthropic's sandbox-runtime:</p> <pre><code>npm install -g @anthropic-ai/sandbox-runtime@0.0.21\n</code></pre> <p>Higher versions should also work, but 0.0.21 is the version used in current tests. </p> <p>Required OS-level packages are:</p>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ripgrep\n</code></pre> <p>macOS uses the native <code>sandbox-exec</code> for process isolation.</p>"},{"location":"installation/#linux","title":"Linux","text":"<pre><code>apt-get install bubblewrap socat ripgrep\n</code></pre> <p>Work in progress</p> <p>Sandboxing on Linux is currently work in progress.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide shows how to run a simple task using the freeact CLI tool and the Agent SDK.</p>"},{"location":"quickstart/#cli-tool","title":"CLI Tool","text":"<p>Freeact provides a CLI tool for running the agent in a terminal. </p>"},{"location":"quickstart/#starting-freeact","title":"Starting Freeact","text":"<p>Create a workspace directory, set your API key, and start the agent:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\necho \"GEMINI_API_KEY=your-api-key\" &gt; .env\nuvx freeact\n</code></pre> <p>See Installation for alternative setup options and sandbox mode prerequisites.</p>"},{"location":"quickstart/#generating-mcp-tool-apis","title":"Generating MCP Tool APIs","text":"<p>On first start, the CLI tool auto-generates Python APIs for configured MCP servers. For example, it creates <code>.freeact/generated/mcptools/google/web_search.py</code> for the <code>web_search</code> tool of the bundled <code>google</code> MCP server. With the generated Python API, the agent can import and call this tool programmatically.</p> <p>Custom MCP servers</p> <p>For calling the tools of your own MCP servers programmatically, add them to the <code>ptc-servers</code> section in <code>.freeact/config.json</code>. Freeact auto-generates a Python API for them when the CLI tool starts.</p>"},{"location":"quickstart/#running-a-task","title":"Running a Task","text":"<p>With this setup and a question like </p> <p>who is F1 world champion 2025? </p> <p>the CLI tool should generate an output similar to the following:</p> <p></p> <p>The recorded session demonstrates:</p> <ul> <li>Progressive tool loading: The agent progressively loads tool information: lists categories, lists tools in the <code>google</code> category, then reads the <code>web_search</code> API to understand its parameters.</li> <li>Programmatic tool calling: The agent writes Python code that imports the <code>web_search</code> tool from <code>mcptools.google</code> and calls it programmatically with the user's query.</li> <li>Action approval: The code action and the programmatic <code>web_search</code> tool call are explicitly approved by the user, other tool calls were pre-approved for this example.</li> </ul> <p>The code execution output shows the search result with source URLs. The agent response is a summary of it.</p>"},{"location":"quickstart/#agent-sdk","title":"Agent SDK","text":"<p>The CLI tool is built on the Agent SDK that you can use directly in your applications. The following minimal example shows how to run the same task programmatically, with code actions and tool calls auto-approved:</p> <pre><code>import asyncio\n\nfrom freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nfrom freeact.agent.config import Config\n\nfrom freeact.tools.pytools.apigen import generate_mcp_sources\n\n\n\nasync def main() -&gt; None:\n    # Scaffold .freeact/ config directory if needed\n    await Config.init()\n\n    # Load configuration from .freeact/\n    config = Config()\n\n    # Generate Python APIs for MCP servers in ptc_servers\n    for server_name, params in config.ptc_servers.items():\n        if not (config.generated_dir / \"mcptools\" / server_name).exists():\n            await generate_mcp_sources({server_name: params}, config.generated_dir)\n\n    async with Agent(config=config) as agent:\n        prompt = \"Who is the F1 world champion 2025?\"\n\n        async for event in agent.stream(prompt):\n            match event:\n                case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                    print(f\"Code action:\\n{args['code']}\")\n                    request.approve(True)\n                case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                    print(f\"Tool: {name}\")\n                    print(f\"Args: {args}\")\n                    request.approve(True)\n                case Thoughts(content=content):\n                    print(f\"Thinking: {content}\")\n                case CodeExecutionOutput(text=text):\n                    print(f\"Code execution output: {text}\")\n                case ToolOutput(content=content):\n                    print(f\"Tool call result: {content}\")\n                case Response(content=content):\n                    print(content)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"sandbox/","title":"Sandbox Mode","text":"<p>Freeact can restrict filesystem and network access for code execution and MCP servers using ipybox sandbox and Anthropic's sandbox-runtime.</p> <p>Prerequisites</p> <p>Check the installation instructions for sandbox mode prerequisites.</p>"},{"location":"sandbox/#code-execution","title":"Code Execution","text":"<p>Scope</p> <p>Sandbox restrictions apply equally to Python code and shell commands, as both execute in the same IPython kernel.</p>"},{"location":"sandbox/#cli-tool","title":"CLI Tool","text":"<p>The <code>--sandbox</code> option enables sandboxed code execution:</p> <pre><code>freeact --sandbox\n</code></pre> <p>A custom configuration file can override the default restrictions:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre>"},{"location":"sandbox/#agent-sdk","title":"Agent SDK","text":"<p>The <code>sandbox</code> and <code>sandbox_config</code> parameters of the <code>Agent</code> constructor provide the same functionality:</p> <pre><code>from pathlib import Path\n\nagent = Agent(\n    \"main\",\n    ...\n    sandbox=True,\n    sandbox_config=Path(\"sandbox-config.json\"),\n)\n</code></pre>"},{"location":"sandbox/#default-restrictions","title":"Default Restrictions","text":"<p>Without a custom configuration file, sandbox mode applies these defaults:</p> <ul> <li>Filesystem: Read all files except <code>.env</code>, write to current directory and subdirectories</li> <li>Network: Internet access blocked, local network access to tool execution server permitted</li> </ul>"},{"location":"sandbox/#custom-configuration","title":"Custom Configuration","text":"sandbox-config.json<pre><code>{\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This macOS-specific example configuration allows additional network access to <code>example.org</code>. Filesystem settings permit writes to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code>, which is required for running a sandboxed IPython kernel. The sandbox configuration file itself is protected from reads and writes.</p>"},{"location":"sandbox/#mcp-servers","title":"MCP Servers","text":"<p>MCP servers run as separate processes and are not affected by code execution sandboxing. Local stdio servers can be sandboxed independently by wrapping the server command with the <code>srt</code> tool from sandbox-runtime. This applies to both <code>mcp-servers</code> and <code>ptc-servers</code> in the configuration file.</p>"},{"location":"sandbox/#filesystem-mcp-server","title":"Filesystem MCP Server","text":"<p>This example shows a sandboxed filesystem MCP server in the <code>mcp-servers</code> section:</p> .freeact/config.json<pre><code>{\n  \"mcp-servers\": {\n    \"filesystem\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-filesystem-mcp.json\",\n        \"npx\", \"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and allows network access to the npm registry, which is required for <code>npx</code> to download the server package:</p> sandbox-filesystem-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sandbox/#fetch-mcp-server","title":"Fetch MCP Server","text":"<p>This example shows a sandboxed fetch MCP server. First, install it locally with:</p> <pre><code>uv add mcp-server-fetch\nuv add \"httpx[socks]&gt;=0.28.1\"\n</code></pre> <p>Then add it to the <code>ptc-servers</code> section:</p> .freeact/config.json<pre><code>{\n  \"ptc-servers\": {\n    \"fetch\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-fetch-mcp.json\",\n        \"python\", \"-m\", \"mcp_server_fetch\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and restricts the MCP server to fetch only from <code>example.com</code>. Access to the npm registry is required for the server's internal operations:</p> sandbox-fetch-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\", \"/tmp/**\", \"/private/tmp/**\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\", \"example.com\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sdk/","title":"Agent SDK","text":"<p>The Agent SDK provides four main APIs:</p> <ul> <li>Configuration API for initializing and loading configuration from <code>.freeact/</code></li> <li>Generation API for generating Python APIs for MCP server tools</li> <li>Agent API for running the agentic code action loop</li> <li>Permissions API for managing approval decisions</li> </ul>"},{"location":"sdk/#configuration-api","title":"Configuration API","text":"<p>Use <code>Config.init()</code> to scaffold the <code>.freeact/</code> directory from default templates. The <code>Config()</code> constructor loads all configuration from it:</p> <pre><code>from freeact.agent.config import Config\n\n# Scaffold .freeact/ config directory if needed\nawait Config.init()\n\n# Load configuration from .freeact/\nconfig = Config()\n</code></pre> <p>See the Configuration reference for details on the <code>.freeact/</code> directory structure.</p>"},{"location":"sdk/#generation-api","title":"Generation API","text":"<p>MCP servers configured as <code>ptc-servers</code> in <code>config.json</code> require Python API generation with <code>generate_mcp_sources()</code> before the agent can call their tools programmatically:</p> <pre><code>from freeact.tools.pytools.apigen import generate_mcp_sources\n\n# Generate Python APIs for MCP servers in ptc_servers\nfor server_name, params in config.ptc_servers.items():\n    if not (config.generated_dir / \"mcptools\" / server_name).exists():\n        await generate_mcp_sources({server_name: params}, config.generated_dir)\n</code></pre> <p>Generated APIs are stored as <code>.freeact/generated/mcptools/&lt;server_name&gt;/&lt;tool&gt;.py</code> modules and persist across agent sessions. The <code>.freeact/generated/</code> directory is on the kernel's <code>PYTHONPATH</code>, so the agent can import them directly:</p> <pre><code>from mcptools.google.web_search import run, Params\n\nresult = run(Params(query=\"python async tutorial\"))\n</code></pre>"},{"location":"sdk/#agent-api","title":"Agent API","text":"<p>The <code>Agent</code> class implements the agentic code action loop, handling code action generation, code execution, tool calls, and the approval workflow. Each <code>stream()</code> call runs a single agent turn, with the agent managing conversation history across calls. Use <code>stream()</code> to iterate over events and handle them with pattern matching:</p> <pre><code>from freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nasync with Agent(config=config) as agent:\n    prompt = \"Who is the F1 world champion 2025?\"\n\n    async for event in agent.stream(prompt):\n        match event:\n            case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                print(f\"Code action:\\n{args['code']}\")\n                request.approve(True)\n            case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                print(f\"Tool: {name}\")\n                print(f\"Args: {args}\")\n                request.approve(True)\n            case Thoughts(content=content):\n                print(f\"Thinking: {content}\")\n            case CodeExecutionOutput(text=text):\n                print(f\"Code execution output: {text}\")\n            case ToolOutput(content=content):\n                print(f\"Tool call result: {content}\")\n            case Response(content=content):\n                print(content)\n</code></pre> <p>For processing output incrementally, match the <code>*Chunk</code> event variants listed below.</p>"},{"location":"sdk/#events","title":"Events","text":"<p>The <code>Agent.stream()</code> method yields events as they occur:</p> Event Description <code>ThoughtsChunk</code> Partial model thoughts (content streaming) <code>Thoughts</code> Complete model thoughts at a given step <code>ResponseChunk</code> Partial model response (content streaming) <code>Response</code> Complete model response <code>ApprovalRequest</code> Pending code action or tool call approval <code>CodeExecutionOutputChunk</code> Partial code execution output (content streaming) <code>CodeExecutionOutput</code> Complete code execution output <code>ToolOutput</code> Tool or built-in operation output <p>All yielded events inherit from <code>AgentEvent</code> and carry <code>agent_id</code>.</p>"},{"location":"sdk/#internal-tools","title":"Internal tools","text":"<p>The agent uses a small set of internal tools for reading and writing files, executing code and commands, spawning subagents, and discovering tools:</p> Tool Implementation Description read, write <code>filesystem</code> MCP server Reading and writing files via JSON tool calls execute <code>ipybox_execute_ipython_cell</code> Execution of Python code and shell commands (via <code>!</code> prefix), delegated to ipybox's <code>CodeExecutor</code> subagent <code>subagent_task</code> Task delegation to child agents tool search <code>pytools</code> MCP server for basic search and hybrid search Tool discovery via category browsing or hybrid search"},{"location":"sdk/#turn-limits","title":"Turn limits","text":"<p>Use <code>max_turns</code> to limit the number of tool-execution rounds before the stream stops:</p> <pre><code>async for event in agent.stream(prompt, max_turns=50):\n    ...\n</code></pre> <p>If <code>max_turns=None</code> (default), the loop continues until the model produces a final response.</p>"},{"location":"sdk/#subagents","title":"Subagents","text":"<p>The built-in <code>subagent_task</code> tool delegates a subtask to a child agent with a fresh IPython kernel and fresh MCP server connections. The child inherits model, system prompt, and sandbox settings from the parent. Its events flow through the parent's stream using the same approval mechanism, with <code>agent_id</code> identifying the source:</p> <pre><code>async for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest(agent_id=agent_id) as request:\n            print(f\"[{agent_id}] Approve {request.tool_name}?\")\n            request.approve(True)\n        case Response(content=content, agent_id=agent_id):\n            print(f\"[{agent_id}] {content}\")\n</code></pre> <p>The main agent's <code>agent_id</code> is <code>main</code>, subagent IDs use the form <code>sub-xxxx</code>. Each delegated task defaults to <code>max_turns=100</code>. The <code>max-subagents</code> setting in <code>config.json</code> limits concurrent subagents (default 5).</p>"},{"location":"sdk/#approval","title":"Approval","text":"<p>The agent provides a unified approval mechanism. It yields <code>ApprovalRequest</code> for all code actions, programmatic tool calls, and JSON tool calls. Execution is suspended until <code>approve()</code> is called. Calling <code>approve(True)</code> executes the code action or tool call; <code>approve(False)</code> rejects it and ends the current agent turn.</p> <pre><code>async for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            # Inspect the pending action\n            print(f\"Tool: {request.tool_name}\")\n            print(f\"Args: {request.tool_args}\")\n\n            # Approve or reject\n            request.approve(True)\n\n        case Response(content=content):\n            print(content)\n</code></pre> <p>Code action approval</p> <p>For code actions, <code>tool_name</code> is <code>ipybox_execute_ipython_cell</code> and <code>tool_args</code> contains the <code>code</code> to execute.</p>"},{"location":"sdk/#lifecycle","title":"Lifecycle","text":"<p>The agent manages MCP server connections and an IPython kernel via ipybox. On entering the async context manager, the IPython kernel starts and MCP servers configured for JSON tool calling connect. MCP servers configured for programmatic tool calling connect lazily on first tool call.</p> <pre><code>config = Config()\nasync with Agent(config=config) as agent:\n    async for event in agent.stream(prompt):\n        ...\n# Connections closed, kernel stopped\n</code></pre> <p>Without using the async context manager:</p> <pre><code>config = Config()\nagent = Agent(config=config)\nawait agent.start()\ntry:\n    async for event in agent.stream(prompt):\n        ...\nfinally:\n    await agent.stop()\n</code></pre>"},{"location":"sdk/#timeouts","title":"Timeouts","text":"<p>The agent supports two timeout settings in <code>config.json</code>:</p> <ul> <li><code>execution-timeout</code>: Maximum time in seconds for each code execution. Approval wait time is excluded from this budget, so the timeout only counts actual execution time. Defaults to 300 seconds. Set to <code>null</code> to disable.</li> <li><code>approval-timeout</code>: Timeout for approval requests during programmatic tool calls. If an approval request is not accepted or rejected within this time, the tool call fails. Defaults to <code>null</code> (no timeout).</li> </ul> <pre><code>{\n  \"execution-timeout\": 60,\n  \"approval-timeout\": 30\n}\n</code></pre>"},{"location":"sdk/#persistence","title":"Persistence","text":"<p><code>SessionStore</code> persists agent message history to <code>.freeact/sessions/&lt;session-uuid&gt;/&lt;agent-id&gt;.jsonl</code>. Each agent turn appends messages incrementally, so the history is durable even if the process terminates mid-session.</p> <pre><code>from freeact.agent.store import SessionStore\n\n# Create a session store with a new session ID\nsession_id = str(uuid.uuid4())\nsession_store = SessionStore(config.sessions_dir, session_id)\n</code></pre> <p>Pass the store to <code>Agent</code> to enable persistence.</p> <pre><code># Run agent with session persistence\nasync with Agent(config=config, session_store=session_store) as agent:\n    await handle_events(agent, \"What is the capital of France?\")\n    await handle_events(agent, \"What about Germany?\")\n</code></pre> <p>To resume a session, create a new <code>SessionStore</code> with the same <code>session_id</code>. The agent loads the persisted message history on startup and continues from where it left off.</p> <pre><code># Resume session with the same session ID\nsession_store = SessionStore(config.sessions_dir, session_id)\n\nasync with Agent(config=config, session_store=session_store) as agent:\n    # Previous message history is restored automatically\n    await handle_events(agent, \"And what was the first country we discussed?\")\n</code></pre> <p>Only the main agent's message history (<code>main.jsonl</code>) is loaded on resume. Subagent messages are persisted to separate files (<code>sub-xxxx.jsonl</code>) for auditing but are not rehydrated.</p> <p>The CLI tool accepts <code>--session-id</code> to resume a session from the command line.</p>"},{"location":"sdk/#permissions-api","title":"Permissions API","text":"<p>Work in progress</p> <p>Current permission management is preliminary and will be reimplemented in a future release.</p> <p>The agent requests approval for each code action and tool call but doesn't remember past decisions. <code>PermissionManager</code> adds memory: <code>allow_always()</code> persists to <code>.freeact/permissions.json</code>, while <code>allow_session()</code> stores in-memory until the session ends:</p> <pre><code>from freeact.permissions import PermissionManager\nfrom ipybox.utils import arun\n\nmanager = PermissionManager()\nawait manager.load()\n\nasync for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            if manager.is_allowed(request.tool_name, request.tool_args):\n                request.approve(True)\n            else:\n                choice = await arun(input, \"Allow? [Y/n/a/s]: \")\n                match choice:\n                    case \"a\":\n                        await manager.allow_always(request.tool_name)\n                        request.approve(True)\n                    case \"s\":\n                        manager.allow_session(request.tool_name)\n                        request.approve(True)\n                    case \"n\":\n                        request.approve(False)\n                    case _:\n                        request.approve(True)\n</code></pre>"},{"location":"api/agent/","title":"Agent","text":""},{"location":"api/agent/#freeact.agent.Agent","title":"freeact.agent.Agent","text":"<pre><code>Agent(\n    config: Config,\n    agent_id: str | None = None,\n    sandbox: bool = False,\n    sandbox_config: Path | None = None,\n    session_store: SessionStore | None = None,\n)\n</code></pre> <p>Code action agent that generates and executes Python code in ipybox.</p> <p>The agent fulfills user requests by writing Python code and running it in a sandboxed IPython kernel where variables persist across executions. Tools can be called in two ways:</p> <ul> <li>JSON tool calls: MCP servers called directly via structured arguments</li> <li>Programmatic tool calls (PTC): Agent writes Python code that imports   and calls tool APIs. These can be auto-generated from MCP schemas   (<code>mcptools/</code>) or user-defined (<code>gentools/</code>).</li> </ul> <p>All tool executions require approval. The <code>stream()</code> method yields <code>ApprovalRequest</code> events that must be resolved before execution proceeds.</p> <p>Use as an async context manager or call <code>start()</code>/<code>stop()</code> explicitly.</p> <p>Initialize the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Agent configuration containing model, system prompt, MCP servers, kernel env, timeouts, and subagent settings.</p> required <code>agent_id</code> <code>str | None</code> <p>Identifier for this agent instance. Defaults to <code>\"main\"</code> when not provided.</p> <code>None</code> <code>sandbox</code> <code>bool</code> <p>Run the kernel in sandbox mode.</p> <code>False</code> <code>sandbox_config</code> <code>Path | None</code> <p>Path to custom sandbox configuration.</p> <code>None</code>"},{"location":"api/agent/#freeact.agent.Agent.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the code executor and connect to MCP servers.</p> <p>Automatically called when entering the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the code executor and disconnect from MCP servers.</p> <p>Automatically called when exiting the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    prompt: str | Sequence[UserContent],\n    max_turns: int | None = None,\n) -&gt; AsyncIterator[AgentEvent]\n</code></pre> <p>Run a full agentic turn, yielding events as they occur.</p> <p>Loops through model responses and tool executions until the model produces a response without tool calls. Both JSON-based and programmatic tool calls yield an <code>ApprovalRequest</code> that must be resolved before execution proceeds.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str | Sequence[UserContent]</code> <p>User message as text or multimodal content sequence.</p> required <code>max_turns</code> <code>int | None</code> <p>Maximum number of tool-execution rounds. Each round consists of a model response followed by tool execution. If None, runs until the model stops calling tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[AgentEvent]</code> <p>An async event iterator.</p>"},{"location":"api/agent/#freeact.agent.AgentEvent","title":"freeact.agent.AgentEvent  <code>dataclass</code>","text":"<pre><code>AgentEvent(*, agent_id: str = '')\n</code></pre> <p>Base class for all agent stream events.</p> <p>Carries the <code>agent_id</code> of the agent that produced the event, allowing callers to distinguish events from a parent agent vs. its subagents.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest","title":"freeact.agent.ApprovalRequest  <code>dataclass</code>","text":"<pre><code>ApprovalRequest(\n    tool_name: str,\n    tool_args: dict[str, Any],\n    _future: Future[bool] = Future(),\n    *,\n    agent_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Pending tool execution awaiting user approval.</p> <p>Yielded by <code>Agent.stream()</code> before executing any tool. The agent is suspended until <code>approve()</code> is called.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approve","title":"approve","text":"<pre><code>approve(decision: bool) -&gt; None\n</code></pre> <p>Resolve this approval request.</p> <p>Parameters:</p> Name Type Description Default <code>decision</code> <code>bool</code> <p><code>True</code> to allow execution, <code>False</code> to reject.</p> required"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approved","title":"approved  <code>async</code>","text":"<pre><code>approved() -&gt; bool\n</code></pre> <p>Await until <code>approve()</code> is called and return the decision.</p>"},{"location":"api/agent/#freeact.agent.Response","title":"freeact.agent.Response  <code>dataclass</code>","text":"<pre><code>Response(content: str, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete model text response after streaming finishes.</p>"},{"location":"api/agent/#freeact.agent.ResponseChunk","title":"freeact.agent.ResponseChunk  <code>dataclass</code>","text":"<pre><code>ResponseChunk(content: str, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial text from an in-progress model response.</p>"},{"location":"api/agent/#freeact.agent.Thoughts","title":"freeact.agent.Thoughts  <code>dataclass</code>","text":"<pre><code>Thoughts(content: str, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete model thoughts after streaming finishes.</p>"},{"location":"api/agent/#freeact.agent.ThoughtsChunk","title":"freeact.agent.ThoughtsChunk  <code>dataclass</code>","text":"<pre><code>ThoughtsChunk(content: str, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial text from model's extended thinking.</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutput","title":"freeact.agent.CodeExecutionOutput  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutput(\n    text: str | None,\n    images: list[Path],\n    *,\n    agent_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete result from Python code execution in the ipybox kernel.</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutputChunk","title":"freeact.agent.CodeExecutionOutputChunk  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutputChunk(text: str, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial output from an in-progress code execution.</p>"},{"location":"api/agent/#freeact.agent.ToolOutput","title":"freeact.agent.ToolOutput  <code>dataclass</code>","text":"<pre><code>ToolOutput(content: ToolResult, *, agent_id: str = '')\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Result from a tool or built-in agent operation.</p>"},{"location":"api/agent/#freeact.agent.store.SessionStore","title":"freeact.agent.store.SessionStore","text":"<pre><code>SessionStore(\n    sessions_root: Path,\n    session_id: str,\n    flush_after_append: bool = False,\n)\n</code></pre> <p>Persist and restore per-agent pydantic-ai message history as JSONL.</p>"},{"location":"api/agent/#freeact.agent.store.SessionStore.append","title":"append","text":"<pre><code>append(agent_id: str, messages: list[ModelMessage]) -&gt; None\n</code></pre> <p>Append serialized messages to an agent-specific session log.</p> <p>Each message is written as a versioned JSONL envelope with a UTC timestamp. The session file is created on demand.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Logical agent stream name (for example, <code>\"main\"</code> or <code>\"sub-1234\"</code>), used as the JSONL filename stem.</p> required <code>messages</code> <code>list[ModelMessage]</code> <p>Messages to append in order.</p> required"},{"location":"api/agent/#freeact.agent.store.SessionStore.load","title":"load","text":"<pre><code>load(agent_id: str) -&gt; list[ModelMessage]\n</code></pre> <p>Load and validate all persisted messages for an agent.</p> <p>Returns an empty list when no session file exists. If the final line is truncated (for example from an interrupted write), that line is ignored. Earlier malformed lines raise <code>ValueError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>Logical agent stream name used to locate the JSONL file.</p> required <p>Returns:</p> Type Description <code>list[ModelMessage]</code> <p>Deserialized message history in append order.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#freeact.agent.config.Config","title":"freeact.agent.config.Config","text":"<pre><code>Config(\n    working_dir: Path | None = None,\n    model: str | Model = DEFAULT_MODEL,\n    model_settings: ModelSettings = DEFAULT_MODEL_SETTINGS,\n)\n</code></pre> <p>Configuration loader for the <code>.freeact/</code> directory structure.</p> <p>Loads and parses all configuration on instantiation: skills metadata, system prompts, MCP servers (JSON tool calls), and PTC servers (programmatic tool calling).</p> <p>Internal MCP servers (pytools, filesystem) are defined as constants in this module. User-defined servers from <code>config.json</code> override internal configs when they share the same key.</p> <p>Attributes:</p> Name Type Description <code>working_dir</code> <code>Path</code> <p>Agent's working directory.</p> <code>freeact_dir</code> <code>Path</code> <p>Path to <code>.freeact/</code> configuration directory.</p> <code>model</code> <p>LLM model name or instance.</p> <code>model_settings</code> <p>Model-specific settings (e.g., thinking config).</p> <code>tool_search</code> <code>str</code> <p>Tool discovery mode read from <code>config.json</code>.</p> <code>images_dir</code> <code>Path | None</code> <p>Directory for saving generated images.</p> <code>execution_timeout</code> <code>float | None</code> <p>Maximum time in seconds for code execution.</p> <code>approval_timeout</code> <code>float | None</code> <p>Timeout in seconds for PTC approval requests.</p> <code>enable_subagents</code> <code>bool</code> <p>Whether to enable subagent delegation.</p> <code>max_subagents</code> <code>int</code> <p>Maximum number of concurrent subagents.</p> <code>kernel_env</code> <code>dict[str, str]</code> <p>Environment variables passed to the IPython kernel.</p> <code>skills_metadata</code> <p>Parsed skill definitions from <code>.freeact/skills/*/SKILL.md</code>.</p> <code>system_prompt</code> <p>Rendered system prompt loaded from package resources.</p> <code>mcp_servers</code> <p>Merged and resolved MCP server configs.</p> <code>ptc_servers</code> <p>Raw PTC server configs loaded from <code>config.json</code>.</p> <code>sessions_dir</code> <code>Path</code> <p>Session trace storage directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.freeact_dir","title":"freeact_dir  <code>property</code>","text":"<pre><code>freeact_dir: Path\n</code></pre> <p>Path to <code>.freeact/</code> configuration directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.generated_dir","title":"generated_dir  <code>property</code>","text":"<pre><code>generated_dir: Path\n</code></pre> <p>Generated MCP tool sources directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.plans_dir","title":"plans_dir  <code>property</code>","text":"<pre><code>plans_dir: Path\n</code></pre> <p>Plan storage directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.search_db_file","title":"search_db_file  <code>property</code>","text":"<pre><code>search_db_file: Path\n</code></pre> <p>Hybrid search database path.</p>"},{"location":"api/config/#freeact.agent.config.Config.sessions_dir","title":"sessions_dir  <code>property</code>","text":"<pre><code>sessions_dir: Path\n</code></pre> <p>Session trace storage directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.working_dir","title":"working_dir  <code>property</code>","text":"<pre><code>working_dir: Path\n</code></pre> <p>Agent's working directory.</p>"},{"location":"api/config/#freeact.agent.config.Config.for_subagent","title":"for_subagent","text":"<pre><code>for_subagent() -&gt; Config\n</code></pre> <p>Create a subagent configuration from this config.</p> <p>Returns a shallow copy with subagent-specific overrides: subagents disabled, mcp_servers deep-copied with pytools sync/watch disabled, and kernel_env shallow-copied for independence.</p>"},{"location":"api/config/#freeact.agent.config.Config.init","title":"init  <code>async</code> <code>classmethod</code>","text":"<pre><code>init(working_dir: Path | None = None) -&gt; None\n</code></pre> <p>Scaffold <code>.freeact/</code> directory from bundled templates.</p> <p>Copies template files that don't already exist, preserving user modifications. Runs blocking I/O in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>working_dir</code> <code>Path | None</code> <p>Base directory. Defaults to current working directory.</p> <code>None</code>"},{"location":"api/config/#freeact.agent.config.SkillMetadata","title":"freeact.agent.config.SkillMetadata  <code>dataclass</code>","text":"<pre><code>SkillMetadata(name: str, description: str, path: Path)\n</code></pre> <p>Metadata parsed from a skill's SKILL.md frontmatter.</p>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL","title":"freeact.agent.config.DEFAULT_MODEL  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL = 'gemini-3-flash-preview'\n</code></pre>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL_SETTINGS","title":"freeact.agent.config.DEFAULT_MODEL_SETTINGS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL_SETTINGS = GoogleModelSettings(\n    google_thinking_config={\n        \"thinking_level\": \"high\",\n        \"include_thoughts\": True,\n    }\n)\n</code></pre>"},{"location":"api/config/#freeact.agent.config.PYTOOLS_BASIC_CONFIG","title":"freeact.agent.config.PYTOOLS_BASIC_CONFIG  <code>module-attribute</code>","text":"<pre><code>PYTOOLS_BASIC_CONFIG: dict[str, Any] = {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"freeact.tools.pytools.search.basic\"],\n    \"env\": {\"PYTOOLS_DIR\": \"${PYTOOLS_DIR}\"},\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.PYTOOLS_HYBRID_CONFIG","title":"freeact.agent.config.PYTOOLS_HYBRID_CONFIG  <code>module-attribute</code>","text":"<pre><code>PYTOOLS_HYBRID_CONFIG: dict[str, Any] = {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"freeact.tools.pytools.search.hybrid\"],\n    \"env\": {\n        \"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\",\n        \"PYTOOLS_DIR\": \"${PYTOOLS_DIR}\",\n        \"PYTOOLS_DB_PATH\": \"${PYTOOLS_DB_PATH}\",\n        \"PYTOOLS_EMBEDDING_MODEL\": \"${PYTOOLS_EMBEDDING_MODEL}\",\n        \"PYTOOLS_EMBEDDING_DIM\": \"${PYTOOLS_EMBEDDING_DIM}\",\n        \"PYTOOLS_SYNC\": \"${PYTOOLS_SYNC}\",\n        \"PYTOOLS_WATCH\": \"${PYTOOLS_WATCH}\",\n        \"PYTOOLS_BM25_WEIGHT\": \"${PYTOOLS_BM25_WEIGHT}\",\n        \"PYTOOLS_VEC_WEIGHT\": \"${PYTOOLS_VEC_WEIGHT}\",\n    },\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.FILESYSTEM_CONFIG","title":"freeact.agent.config.FILESYSTEM_CONFIG  <code>module-attribute</code>","text":"<pre><code>FILESYSTEM_CONFIG: dict[str, Any] = {\n    \"command\": \"npx\",\n    \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \".\",\n    ],\n    \"excluded_tools\": [\n        \"create_directory\",\n        \"list_directory\",\n        \"list_directory_with_sizes\",\n        \"directory_tree\",\n        \"move_file\",\n        \"search_files\",\n        \"list_allowed_directories\",\n        \"read_file\",\n    ],\n}\n</code></pre>"},{"location":"api/generate/","title":"Generate","text":""},{"location":"api/generate/#freeact.tools.pytools.apigen.generate_mcp_sources","title":"freeact.tools.pytools.apigen.generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    config: dict[str, dict[str, Any]], generated_dir: Path\n) -&gt; None\n</code></pre> <p>Generate Python API for MCP servers in <code>config</code>.</p> <p>For servers not already in <code>mcptools/</code> categories, generates Python API using <code>ipybox.generate_mcp_sources</code>.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, dict[str, Any]]</code> <p>Dictionary mapping server names to server configurations.</p> required <code>generated_dir</code> <code>Path</code> <p>Directory for generated tool sources.</p> required"},{"location":"api/permissions/","title":"Permissions","text":""},{"location":"api/permissions/#freeact.permissions.PermissionManager","title":"freeact.permissions.PermissionManager","text":"<pre><code>PermissionManager(freeact_dir: Path = Path('.freeact'))\n</code></pre> <p>Tool permission gating with two-tier approval: always-allowed (persisted) and session-only (in-memory).</p> <p>Filesystem tools targeting paths within <code>.freeact/</code> are auto-approved without explicit permission grants.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_always","title":"allow_always  <code>async</code>","text":"<pre><code>allow_always(tool_name: str) -&gt; None\n</code></pre> <p>Grant permanent permission for a tool and persist to disk.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_session","title":"allow_session","text":"<pre><code>allow_session(tool_name: str) -&gt; None\n</code></pre> <p>Grant permission for a tool until the session ends (not persisted).</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.is_allowed","title":"is_allowed","text":"<pre><code>is_allowed(\n    tool_name: str, tool_args: dict[str, Any] | None = None\n) -&gt; bool\n</code></pre> <p>Check if a tool call is pre-approved.</p> <p>Returns <code>True</code> if the tool is in the always-allowed or session-allowed set, or if it's a filesystem tool operating within <code>.freeact/</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.load","title":"load  <code>async</code>","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load always-allowed tools from <code>.freeact/permissions.json</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.save","title":"save  <code>async</code>","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persist always-allowed tools to <code>.freeact/permissions.json</code>.</p>"},{"location":"examples/agent-skills/","title":"Custom Agent Skills","text":"<p>Freeact supports the agentskills.io specification, a lightweight format for extending agent capabilities with specialized knowledge and workflows. Skills that guide code execution are particularly well-suited for freeact's code action approach. Skills are loaded on demand: only metadata is in context initially, full instructions load when relevant.  </p>"},{"location":"examples/agent-skills/#pdf-generation","title":"PDF Generation","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example uses the PDF skill from the Anthropic skills repository, a collection of production-quality skills maintained by Anthropic.</p> <p>Create a workspace with a virtual environment and install the required dependencies for this example:</p> <pre><code>uv pip install reportlab\n</code></pre> <p>Install the PDF skill:</p> <pre><code>git clone https://github.com/anthropics/skills.git /tmp/skills\nmkdir -p .freeact/skills\ncp -r /tmp/skills/skills/pdf .freeact/skills/\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>When asked to</p> <p>calculate compound interest for $10,000 at 5% for 10 years, save result to output/compound_interest.pdf</p> <p>the agent:</p> <ol> <li>Identifies the PDF skill as relevant based on the request to create a PDF document</li> <li>Loads the skill instructions by reading the <code>pdf/SKILL.md</code> file</li> <li>Performs the calculation and generates a PDF following the skill's guidance</li> </ol> <p></p>"},{"location":"examples/output-parser/","title":"Enhancing Tools","text":"<p>Many MCP servers lack output schemas. For example, all tools of the GitHub MCP server return a JSON string without defining an output schema. Without an output schema, the <code>run()</code> function of the generated tool API returns a plain string instead of a structured <code>Result</code> type.</p> <p>Without knowing output structure beforehand, an agent cannot reliably write code that processes tool output inside a code action. It must retrieve raw results into context for inspection, then write processing logic in another inference round.</p> <p>Freeact's bundled <code>output-parsers</code> skill solves this by generating output parsers that enhance tool APIs with a <code>run_parsed()</code> function that returns a structured output type. With output types known, the agent can generate processing logic in a single inference round. </p> <p>This tool enhancement persists across sessions and is an example of the agent acting as a toolsmith, enhancing its own tool library rather than just executing tasks.</p>"},{"location":"examples/output-parser/#output-parser-generation","title":"Output Parser Generation","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>Create a workspace and initialize the configuration directory:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact init\n</code></pre> <p>Add the GitHub MCP server to <code>ptc-servers</code> in <code>.freeact/config.json</code>:</p> <pre><code>{\n  \"ptc-servers\": {\n    \"github\": {\n      \"url\": \"https://api.githubcopilot.com/mcp/\",\n      \"headers\": {\"Authorization\": \"Bearer ${GITHUB_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Set your GitHub personal access token (PAT) as the <code>GITHUB_API_KEY</code> environment variable or add it to <code>.env</code>. </p> <p>Then start the CLI tool to automatically generate Python APIs to <code>.freeact/generated/mcptools/github/</code>:</p> <pre><code>uvx freeact\n</code></pre> <p>When asked to </p> <p>create an output parser for search_repositories</p> <p>the agent </p> <ol> <li>Loads the <code>output-parsers</code> skill and the generated <code>search_repositories.py</code> tool API</li> <li>Calls the <code>search_repositories.run()</code> function with example inputs to observe outputs</li> <li>Identifies parseable JSON with fields like <code>name</code>, <code>description</code>, <code>stargazers_count</code>, etc.</li> <li>Creates an enhanced tool API with <code>ParseResult</code>, <code>Repository</code> and <code>run_parsed()</code></li> <li>Saves the parser to a separate <code>.freeact/generated/mcpparse/github/search_repositories.py</code></li> <li>Resets the IPython kernel to re-import the tool for testing <code>run_parsed()</code></li> </ol> <p></p> <p>The enhanced tool can now be composed with other tools in a single code action, with full type information available for processing intermediate results.</p>"},{"location":"examples/python-packages/","title":"Data analysis","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>Freeact can use any Python package available in the execution environment. This example demonstrates using scikit-learn and matplotlib directly in code actions to fit a Gaussian Process Regressor to noisy sine wave data and visualize the results with uncertainty bounds.</p> <p>Create a workspace with a virtual environment and install the required dependencies:</p> <pre><code>uv pip install scikit-learn matplotlib\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>In the recording below, the agent performs Gaussian Process Regression in response to a single prompt:</p> <p>Generate 30 noisy samples from a sine function and fit a Gaussian process regressor to the data. Save the result as a plot with uncertainty bounds to output/gpr_sine.png.</p> <p>The agent generates the samples, fits a <code>GaussianProcessRegressor</code> with an RBF kernel, and creates a visualization showing the true sine function, noisy samples, model predictions, and uncertainty bounds.</p> <p>A follow-up prompt asks for model statistics:</p> <p>print the stats</p> <p>The agent prints the log-marginal-likelihood and other attributes from the fitted model.</p> <p></p> <p>The resulting plot shows the GPR fit with a confidence interval:</p> <p></p>"},{"location":"examples/sandbox-mode/","title":"Sandbox Mode","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example demonstrates running code execution in sandbox mode with a custom sandbox configuration. It does not cover sandboxing MCP servers.</p> <p>Create a workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\n</code></pre> <p>Create a <code>sandbox-config.json</code> file in your workspace directory:</p> sandbox-config.json<pre><code>{\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This configuration allows network access only to <code>example.org</code> and protects the sandbox config file from being read or modified. The <code>allowLocalBinding</code> and write access to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code> are required for the sandboxed IPython kernel to operate on macOS.</p> <p>Start the CLI tool with the custom sandbox configuration:</p> <pre><code>uvx freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>The recording below demonstrates the sandbox in action. First, the agent can access the allowed domain:</p> <p>use requests to read from example.org, print status code only</p> <p>This succeeds with status <code>200</code>. Other domains are blocked:</p> <p>now from google.com</p> <p>This fails with a <code>403 Forbidden</code>. The sandbox also protects the config file:</p> <p>print the content of sandbox-config.json in a code action</p> <p>This fails with a <code>PermissionError</code>.</p> <p></p>"},{"location":"examples/saving-codeacts/","title":"Code Action Reuse","text":"<p>Any code action can be saved as a discoverable tool, enabling tool libraries to evolve as agents work. Composite code actions that chain multiple tools are a common example.</p> <p>Freeact provides the <code>saving-codeacts</code> skill for saving code actions as reusable tools. It separates interface (<code>api.py</code>) from implementation (<code>impl.py</code>). The interface contains the function signature, Pydantic models, and docstrings. The implementation contains the actual logic. </p> <p>This separation enables efficient tool discovery: agents inspect signatures and docstrings without loading implementation details. The implementation stays hidden, saving tokens and reducing distraction by keeping non-essential details out of context.</p> <p>The following example shows how to compose and save a code action as a parameterized tool, then discover and reuse it in a new session.</p>"},{"location":"examples/saving-codeacts/#compose-and-save","title":"Compose and Save","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>This example continues from the enhancing tools example, where <code>search_repositories</code> was augmented with a <code>run_parsed()</code> function returning typed <code>Repository</code> objects. In the same workspace, start a new CLI tool session with:</p> <pre><code>uvx freeact\n</code></pre> <p>With a query like</p> <p>get the latest 5 commits of the 3 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers <code>search_repositories</code> and <code>list_commits</code> as appropriate tools and inspects their APIs. Because the enhanced <code>search_repositories</code> tool now returns typed output via <code>run_parsed()</code>, the agent can compose these tools in a single code action, passing repository names from search results as input to <code>list_commits</code><sup>1</sup>.</p> <p>After code action execution, the agent is instructed to save it as a reusable tool:</p> <p>save this as tool under category github, with username, top_n_repos, top_n_commits as parameter</p> <p>The agent:</p> <ol> <li>Loads the <code>saving-codeacts</code> skill</li> <li>Creates a <code>gentools/github/commits_of_top_repos/</code> package under <code>.freeact/generated/</code></li> <li>Saves the tool API with a parameterized <code>run()</code> function to <code>api.py</code></li> <li>Saves the implementation to <code>impl.py</code>, lazily imported by <code>run()</code></li> <li>Tests the saved tool to verify it works</li> </ol> <p>The structure of the saved tool is:</p> <pre><code>.freeact/generated/gentools/\n\u2514\u2500\u2500 github/\n    \u2514\u2500\u2500 commits_of_top_repos/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre> <p></p>"},{"location":"examples/saving-codeacts/#discover-and-reuse","title":"Discover and Reuse","text":"<p>Recorded session</p> <p>A recorded session of this example is appended below.</p> <p>In a new session, the saved tool is discovered like any other Python tool. During discovery, only the API is inspected, not the implementation. When asked to</p> <p>get the latest 3 commits of the 2 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers the previously saved tool, inspects its API, and calls it with different parameters (<code>top_n_repos=2</code>, <code>top_n_commits=3</code>).</p> <p></p> <ol> <li> <p>Since <code>list_commits</code> doesn't return typed output, the agent guesses output structure from training data, which may or may not work on first attempt. This can be made more reliable by also generating an output parser for <code>list_commits</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"internal/","title":"Internal Documentation","text":"<p>Agent-optimized reference material. Not published via MkDocs.</p> <p>Do not use mkdocs-formatter, mkdocs-docstrings, or freeact-docs-style skills for files in this directory.</p>"},{"location":"internal/architecture/","title":"Architecture","text":"<p>This page documents agent runtime architecture only (<code>freeact/agent/*</code>). It intentionally excludes CLI, terminal UX, and longer-lived permission policy layers.</p>"},{"location":"internal/architecture/#core-agent","title":"Core Agent","text":"<ul> <li><code>freeact/agent/core.py</code> contains the main orchestration loop.</li> <li><code>Agent.stream()</code> yields typed events (<code>ResponseChunk</code>, <code>Response</code>, <code>Thoughts*</code>, <code>ApprovalRequest</code>, <code>CodeExecutionOutput*</code>, <code>ToolOutput</code>).</li> <li>Tool dispatch is centralized in <code>_execute_tool()</code> and uses <code>match</code>/<code>case</code>.</li> <li>Multiple tool calls from one model turn execute concurrently via <code>aiostream.merge</code>.</li> </ul>"},{"location":"internal/architecture/#subagents","title":"Subagents","text":"<ul> <li>Subagents are invoked through <code>subagent_task</code>.</li> <li><code>_execute_subagent_task()</code> creates a nested <code>Agent</code> with <code>enable_subagents=False</code>.</li> <li>Parent and subagent events share one stream and are separated by <code>agent_id</code>.</li> <li>Concurrent subagents are bounded by <code>max_subagents</code> via <code>asyncio.Semaphore</code>.</li> </ul>"},{"location":"internal/architecture/#configuration","title":"Configuration","text":"<ul> <li><code>freeact/agent/config/</code> handles <code>.freeact/</code> initialization and loading.</li> <li><code>Config.init()</code> scaffolds missing files only; it does not overwrite existing user files.</li> </ul>"},{"location":"internal/architecture/#tools","title":"Tools","text":"<ul> <li>Bundled tool-definition caches:</li> <li>ipybox tools: <code>freeact/tools/ipybox.json</code></li> <li>subagent tool: <code>freeact/tools/subagent.json</code></li> <li>JSON MCP calls use <code>mcp-servers</code>.</li> <li>Programmatic tool calling uses generated Python APIs from <code>ptc-servers</code> in <code>.freeact/generated/mcptools/</code>.</li> <li>User-defined generated tools live in <code>.freeact/generated/gentools/</code>.</li> </ul>"},{"location":"internal/architecture/#sessions","title":"Sessions","text":"<ul> <li>Session persistence: <code>freeact/agent/store.py</code>.</li> <li>Main-session rehydration loads <code>main.jsonl</code>; subagent JSONL files are persisted for audit.</li> </ul>"},{"location":"internal/architecture/#approvals","title":"Approvals","text":"<ul> <li>All tool executions require approval and surface as <code>ApprovalRequest</code> (including nested programmatic tool calls encountered during <code>ipybox_execute_ipython_cell</code>).</li> <li>Rejected approvals are reflected as rejected tool returns and end the current agent turn with a <code>\"Tool call rejected\"</code> response.</li> </ul>"}]}